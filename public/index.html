<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Omni Visualizer</title>
  <link rel="stylesheet" href="css/fonts.css">
  <link rel="stylesheet" href="css/omni-style.css">
</head>
<body>
  <div class="control-panel">
    <h2>Pattern</h2>
    
    <div class="page-toggler">
      <a href="index.html" class="page-toggle-button active">Pattern</a>
      <a href="manipulator.html" id="manipulatorLink" class="page-toggle-button">Globe</a>
      <a href="globe_spin_geo.html" id="globeSpinGeoLink" class="page-toggle-button">Globe Spin Geo</a>
    </div>

    <!-- Global Hexagon Size Control -->
    <div class="background-control" style="margin-top: 15px;">
      <div class="slider-container">
        <label for="hexagonSizeSlider" style="min-width: 100px;">Hexagon Size:</label>
        <input type="range" id="hexagonSizeSlider" min="40" max="160" value="80" step="5">
        <span id="hexagonSizeValue" class="value-display" style="min-width: 40px;">80</span>
      </div>
    </div>

    <!-- Preset Selector -->
    <div class="background-control">
        <div class="slider-container">
            <label for="presetSelect" style="min-width: 100px;">Preset:</label>
            <select id="presetSelect" class="color-select" style="flex-grow: 1; margin-bottom: 5px;">
                <option value="none">None</option>
                <option value="egnyte">Egnyte</option>
                <option value="aec">AEC</option>
                <option value="financial">Financial Services</option>
                <option value="lifesciences">Life Sciences</option>
                <option value="channel">Channel Partners</option>
                <option value="media">Media & Entertainment</option>
            </select>
        </div>
        <div class="slider-container" style="margin-top: 0px;">
            <label for="presetColorSelect" style="min-width: 100px;">Preset Color:</label>
            <select id="presetColorSelect" class="color-select" style="flex-grow: 1;">
                <option value="none">None</option>
                <option value="color-on-white">Color on White</option>
                <option value="light-grey-on-white">Light Grey on White</option>
                <option value="medium-grey-on-white">Medium Grey on White</option>
                <option value="black-on-white">Black on White</option>
                <option value="black-on-color">Black on Color</option>
                <option value="color-on-black">Color on Black</option>
                <option value="color-on-light-grey">Color on Light Grey</option>
                <option value="black-on-light-grey">Black on Light Grey</option>
                <option value="medium-grey-on-light-grey">Medium Grey on Light Grey</option>
                <option value="color-on-medium-grey">Color on Medium Grey</option>
                <option value="black-on-medium-grey">Black on Medium Grey</option>
                <option value="light-grey-on-medium-grey">Light Grey on Medium Grey</option>
            </select>
        </div>
    </div>

    <!-- Line Weight Control -->
    <div class="background-control">
      <div class="slider-container">
        <label for="globalLineWeightSlider" style="min-width: 100px;">Line Weight:</label>
        <input type="range" id="globalLineWeightSlider" min="0" max="3" value="0" step="1" style="flex-grow: 1;">
        <span id="globalLineWeightValue" class="value-display" style="min-width: 40px;">1.0</span>
      </div>
      <div class="checkbox-container" style="margin-top: 5px;">
        <label for="lockLineWeight">Lock Weight:</label>
        <input type="checkbox" id="lockLineWeight" checked>
      </div>
    </div>

    <!-- Customizer Section -->
    <div class="background-control customizer-section" id="customizerSection"> <!-- Added ID -->
      <h4 style="margin-bottom: 10px; margin-top:0px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;" id="customizerHeader">
        Customizer
        <span class="customizer-arrow">&#9654;</span>
      </h4>
      <div id="customizerContent" style="display: none;"> <!-- Content wrapper, collapsed by default -->
        <!-- Color Controls (now inside Customizer) -->
        <div style="padding-bottom: 10px;"> 
          <h5 style="margin-bottom: 10px; margin-top:0px; font-size: 0.95em;">Color Controls</h5>
          <div class="slider-container"> 
            <label for="globalLineColorSelect" style="min-width: 100px;">Line Color:</label>
          <select id="globalLineColorSelect" class="color-select" style="flex-grow: 1;">
            <option value="#000000">Black</option>
            <option value="#F0F5F7">Light Grey</option>
            <option value="#B6C0C4">Medium Grey</option>
            <option value="#0BC5BA">Egnyte Teal</option>
            <option value="#FF6640">AEC Orange</option>
            <option value="#DA9DFF">Financial Purple</option>
            <option value="#359DFF">LifeSci Blue</option>
            <option value="#85E961">Channel Green</option>
            <option value="#FF51B6">Media Pink</option>
          </select>
        </div>
        <div class="checkbox-container" style="margin-top: 5px; margin-bottom: 10px;">
          <label for="lockLineColor">Lock Color:</label>
          <input type="checkbox" id="lockLineColor">
        </div>

        <!-- Background Color Control -->
        <div class="slider-container" style="margin-top: 10px;">
          <label for="backgroundColorSelect" style="min-width: 100px;">Background:</label>
          <select id="backgroundColorSelect" class="color-select" style="flex-grow: 1;">
            <option value="#FFFFFF">White</option>
            <option value="#F0F5F7">Light Grey</option>
            <option value="#B6C0C4">Medium Grey</option>
            <option value="#000000">Black</option>
            <option value="#0BC5BA">Egnyte Teal</option>
            <option value="#FF6640">AEC Orange</option>
            <option value="#DA9DFF">Financial Purple</option>
            <option value="#359DFF">LifeSci Blue</option>
            <option value="#85E961">Channel Green</option>
            <option value="#FF51B6">Media Pink</option>
          </select>
        </div>
        <div class="checkbox-container" style="margin-top: 5px; margin-bottom: 10px;">
          <label for="lockBackgroundColor">Lock Background:</label>
          <input type="checkbox" id="lockBackgroundColor">
        </div>
      </div>

      <!-- Line Length Controls Sub-section (inside Customizer) -->
      <div style="padding-top: 15px; margin-top:15px; border-top: 1px solid #dee2e6;"> <!-- Plain div with top border for separation -->
        <h5 style="margin-bottom: 10px; margin-top:0px; font-size: 0.95em;">Line Length Controls</h5>
        <!-- Tab Navigation -->
        <div class="tab-navigation">
          <button class="tab-button active" data-tab="bars">Bars</button>
          <button class="tab-button" data-tab="stars">Stars</button>
        </div>

        <!-- Tab Content -->
        <div class="tab-content">
          <div id="bars" class="tab-pane active">
            <h4 style="display:none;">Bars Controls</h4> <!-- Hide original H4 if sub-section has title -->
            <!-- Content generated by JS -->
          </div>
          <div id="stars" class="tab-pane">
            <h4 style="display:none;">Stars Controls</h4> <!-- Hide original H4 if sub-section has title -->
            <!-- Content generated by JS -->
          </div>
          <!-- Test tab content removed -->
        </div>
      </div>
    </div> <!-- End of customizerContent -->
    </div> <!-- End of customizerSection -->

    <!-- Reset Settings Button -->
    <div class="background-control" style="margin-top: 10px;">
        <button id="resetAllSettingsButton" class="reset-defaults-button" style="width: 100%;">Reset Settings</button>
    </div>
    
    <!-- SVG Download Section -->
    <div class="background-control" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ccc;">
      <h4 style="margin-bottom: 10px;">SVG Download</h4>
      <div class="slider-container" style="margin-bottom: 5px;">
        <label for="hexagonsWideInput" style="min-width: 120px;">Hexagons Wide:</label>
        <input type="number" id="hexagonsWideInput" value="10" min="1" style="width: 60px; text-align: right; margin-right: 5px;">
      </div>
      <div class="slider-container" style="margin-bottom: 10px;">
        <label for="hexagonsTallInput" style="min-width: 120px;">Hexagons Tall:</label>
        <input type="number" id="hexagonsTallInput" value="7" min="1" style="width: 60px; text-align: right; margin-right: 5px;">
      </div>
      <button id="downloadSvgButton" class="randomize-button" style="width: 100%;">Download SVG</button>
    </div>

  </div>
  
  <div class="visualization-panel">
    <svg id="omniVisualizationSvg" class="pattern-display-area" width="100%" height="100%" viewBox="-400 -300 800 600" style="max-width: 800px; max-height: 600px;"></svg>
  </div>
  
  <script type="module">
    import { drawHexagonGrid, updateLineLength, BASE_LINE_IDS, updateGlobalLineColor, updateGlobalLineWeight } from './js/omniHexagon.js';

    const OMNI_INDEX_STATE_KEY = 'omniIndexState';
    const defaultHexRadius = 80;
    const viewBoxData = { x: -400, y: -300, width: 800, height: 600 };
    const svgContainer = document.getElementById('omniVisualizationSvg'); 
    const hexagonSizeSlider = document.getElementById('hexagonSizeSlider');
    const hexagonSizeValueDisplay = document.getElementById('hexagonSizeValue');
    const globalLineColorSelect = document.getElementById('globalLineColorSelect');
    const lockLineColorCheckbox = document.getElementById('lockLineColor'); 
    const globalLineWeightSlider = document.getElementById('globalLineWeightSlider');
    const globalLineWeightValueDisplay = document.getElementById('globalLineWeightValue');
    const lockLineWeightCheckbox = document.getElementById('lockLineWeight'); 
    const presetSelect = document.getElementById('presetSelect');
    const presetColorSelect = document.getElementById('presetColorSelect'); // New
    const backgroundColorSelect = document.getElementById('backgroundColorSelect');
    const lockBackgroundColorCheckbox = document.getElementById('lockBackgroundColor');
    // const visualizationPanel = document.querySelector('.visualization-panel'); // No longer needed for BG color

    const PRESET_ACCENT_COLORS = {
        "egnyte": "#0BC5BA",
        "aec": "#FF6640",
        "financial": "#DA9DFF",
        "lifesciences": "#359DFF",
        "channel": "#85E961",
        "media": "#FF51B6",
        "none": "#000000" // Default for 'none' preset
    };

    const GREY_COLORS = {
        light: '#F0F5F7',
        medium: '#B6C0C4',
        white: '#FFFFFF',
        black: '#000000'
    };

    const allowedLineWeights = [1, 1.5, 2.5, 4];
    const DEFAULT_BACKGROUND_COLOR = '#FFFFFF';
    const DEFAULT_BACKGROUND_LOCK = false;
    const DEFAULT_PRESET_COLOR_OPTION = 'none';
    const CUSTOMIZER_STATE_KEY = 'omniCustomizerState'; // For local storage of expand/collapse
    const DEFAULT_SELECT_BG_COLOR = '#F0F5F7'; // Match other inputs
    
    let currentGlobalLineColor = '#000000'; 
    let currentGlobalLineWeight = allowedLineWeights[0]; // Default to 1.0
    let currentBackgroundColor = DEFAULT_BACKGROUND_COLOR;
    let currentPresetColorOption = DEFAULT_PRESET_COLOR_OPTION;
    let isLineColorLocked = false; 
    let isLineWeightLocked = true; 
    let isBackgroundColorLocked = DEFAULT_BACKGROUND_LOCK;
    let isCustomizerExpanded = false; // Default to collapsed
    let currentActiveTabId = 'bars'; 

    const customizerHeader = document.getElementById('customizerHeader');
    const customizerContent = document.getElementById('customizerContent');
    const customizerSection = document.getElementById('customizerSection');


    const tabButtons = document.querySelectorAll('.tab-button');
    const tabPanes = document.querySelectorAll('.tab-content .tab-pane');

    const currentLinePercentages = {};
    BASE_LINE_IDS.forEach(id => currentLinePercentages[id] = 100); 

    const percentageMap = [0, 25, 50, 75, 100]; 

    const batchedInBarsSetup = {
        "vertical-spokes": ["spoke-c-p6", "spoke-c-p12"],
        "horizontal-edge-spokes": ["spoke-c-p3", "spoke-c-p9"],
        "diagonal-edge-spokes": ["spoke-c-p1", "spoke-c-p5", "spoke-c-p7", "spoke-c-p11"],
        "diagonal-corner-spokes": ["spoke-c-p2", "spoke-c-p4", "spoke-c-p8", "spoke-c-p10"]
    };
    
    const batchedInStarsSetup = {
        "y-batch": ["spoke-c-p2", "spoke-c-p6", "spoke-c-p10"],
        "a-batch": ["spoke-c-p12", "spoke-c-p4", "spoke-c-p8"],
        "x-batch": ["spoke-c-p3", "spoke-c-p9", "spoke-c-p1", "spoke-c-p5", "spoke-c-p7", "spoke-c-p11"]
    };

    function updateSliderUI(sliderElement, percentage) {
        if (sliderElement) {
            const sliderValueIndex = percentageMap.indexOf(percentage);
            sliderElement.value = sliderValueIndex !== -1 ? sliderValueIndex : 4; 
            const displaySpan = sliderElement.nextElementSibling;
            if (displaySpan && displaySpan.classList.contains('value-display')) {
                displaySpan.textContent = `${percentage}%`;
            }
        }
    }
    
    function setBatchLines(lineIds, percentage, batchSliderElement = null) {
        lineIds.forEach(baseId => {
            updateLineLength(baseId, percentage);
            currentLinePercentages[baseId] = percentage;
            const testTabSlider = document.getElementById(`slider-test-${baseId}`);
            updateSliderUI(testTabSlider, percentage);
        });
        if (batchSliderElement) {
            updateSliderUI(batchSliderElement, percentage);
        }
    }

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabPanes.forEach(pane => pane.classList.remove('active'));
            button.classList.add('active');
            currentActiveTabId = button.getAttribute('data-tab'); 
            const activePane = document.getElementById(currentActiveTabId);
            if (activePane) activePane.classList.add('active');

            BASE_LINE_IDS.forEach(baseId => {
                updateLineLength(baseId, 100);
                currentLinePercentages[baseId] = 100;
            });
            document.querySelectorAll('input[type="range"][data-base-lineid], input[type="range"][data-batch-type]').forEach(slider => {
                 updateSliderUI(slider, 100);
            });
            if (presetSelect.value !== "none") {
                presetSelect.value = "none";
                if (presetColorSelect) {
                    presetColorSelect.value = "none";
                    presetColorSelect.disabled = true;
                }
                currentPresetColorOption = "none";
                updatePresetSelectAppearance("none"); // Reset appearance
            }
            saveOmniIndexState(); // Save state on tab change
        });
    });
    
    function getSliderValueFromPercentage(percentage) {
        const index = percentageMap.indexOf(percentage);
        return index !== -1 ? index : 4; 
    }

    function populateLineControlsForTab(tabPaneElement, baseLineIdsArray) {
        if (!tabPaneElement || !baseLineIdsArray || baseLineIdsArray.length === 0) return;
        const h4 = tabPaneElement.querySelector('h4'); 
        tabPaneElement.innerHTML = ''; 
        if (h4) tabPaneElement.appendChild(h4);
        
        const p = document.createElement('p');
        p.className = 'placeholder-text';
        p.textContent = `Controls for ${h4 ? h4.textContent.replace(' Controls', '') : tabPaneElement.id}:`;
        tabPaneElement.appendChild(p);
        
        const createSliderGroup = (labelText, idSuffix, batchTypeOrBaseId, relevantLineIds) => {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'slider-container batch-control-group';
            const label = document.createElement('label');
            const sliderFullId = `slider-${idSuffix}`;
            label.htmlFor = sliderFullId;
            label.textContent = labelText;
            label.style.fontWeight = 'bold';
            label.style.minWidth = '150px';
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.id = sliderFullId;
            slider.min = "0";
            slider.max = "4";
            slider.step = "1";
            const isBatch = Array.isArray(relevantLineIds) && relevantLineIds.length > 1;
            if (isBatch) slider.dataset.batchType = batchTypeOrBaseId;
            else slider.dataset.baseLineid = batchTypeOrBaseId; 
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'value-display';
            valueDisplay.style.minWidth = '40px';
            let initialPercentage = 100;
            if (isBatch) {
                const firstLineId = relevantLineIds[0];
                if (currentLinePercentages.hasOwnProperty(firstLineId)) {
                    const firstLinePercentage = currentLinePercentages[firstLineId];
                    if (relevantLineIds.every(id => currentLinePercentages[id] === firstLinePercentage)) {
                        initialPercentage = firstLinePercentage;
                    }
                }
            } else { 
                 initialPercentage = currentLinePercentages[batchTypeOrBaseId] !== undefined ? currentLinePercentages[batchTypeOrBaseId] : 100;
            }
            slider.value = getSliderValueFromPercentage(initialPercentage);
            valueDisplay.textContent = `${initialPercentage}%`;
            slider.addEventListener('input', function() {
                const currentSliderVal = parseInt(this.value);
                const percentage = percentageMap[currentSliderVal];
                valueDisplay.textContent = `${percentage}%`;
                const linesToUpdate = isBatch ? relevantLineIds : [batchTypeOrBaseId];
                linesToUpdate.forEach(baseId => {
                    updateLineLength(baseId, percentage);
                    currentLinePercentages[baseId] = percentage;
                });
                if (presetSelect.value !== "none") {
                    presetSelect.value = "none";
                    if (presetColorSelect) {
                        presetColorSelect.value = "none";
                        presetColorSelect.disabled = true;
                    }
                    currentPresetColorOption = "none";
                    updatePresetSelectAppearance("none"); // Reset appearance
                }
                saveOmniIndexState(); // Save state when a dynamic slider changes
                if (isBatch) { 
                    linesToUpdate.forEach(baseId => { 
                        document.querySelectorAll(`input[type="range"][data-base-lineid="${baseId}"]`).forEach(indSlider => {
                            if (!indSlider.id.includes('-batch-')) updateSliderUI(indSlider, percentage);
                        });
                    });
                    if (batchTypeOrBaseId === "border") {
                         const otherTabId = tabPaneElement.id === "stars" ? "bars" : "stars";
                         const otherBatchSlider = document.getElementById(`slider-${otherTabId}-batch-border`);
                         updateSliderUI(otherBatchSlider, percentage);
                    }
                } else { 
                    const singleBaseId = batchTypeOrBaseId;
                    document.querySelectorAll(`input[type="range"][data-base-lineid="${singleBaseId}"]`).forEach(otherIndSlider => {
                        if (otherIndSlider !== this && !otherIndSlider.id.includes('-batch-')) updateSliderUI(otherIndSlider, percentage);
                    });
                }
            });
            groupDiv.appendChild(label); groupDiv.appendChild(slider); groupDiv.appendChild(valueDisplay);
            tabPaneElement.appendChild(groupDiv);
        };

        if (tabPaneElement.id === "stars" || tabPaneElement.id === "bars") {
            createSliderGroup("ALL BORDERS:", `${tabPaneElement.id}-batch-border`, "border", BASE_LINE_IDS.filter(id => id.startsWith("border-")));
        }
        if (tabPaneElement.id === "bars") {
            for(const batchKey in batchedInBarsSetup) {
                const label = batchKey.replace(/-/g, ' ').replace('spokes', '').replace('stars', '').trim().split(' ').map(w => w[0].toUpperCase() + w.substring(1)).join(' ') + ":";
                createSliderGroup(label, `bars-batch-${batchKey}`, batchKey, batchedInBarsSetup[batchKey]);
            }
        }
        if (tabPaneElement.id === "stars") {
             for(const batchKey in batchedInStarsSetup) {
                let label = batchKey.replace(/-/g, ' ').replace('spokes', '').replace('stars', '').trim().split(' ').map(w => w[0].toUpperCase() + w.substring(1)).join(' ');
                if (label === "Y Batch" || label === "A Batch" || label === "Horizontal" || label === "Diagonal Edge") {} else { label += ":"; } 
                createSliderGroup(label, `stars-batch-${batchKey}`, batchKey, batchedInStarsSetup[batchKey]);
            }
        }
        baseLineIdsArray.forEach(baseLineId => {
            let skip = false;
            if ((tabPaneElement.id === "stars" || tabPaneElement.id === "bars") && baseLineId.startsWith("border-")) skip = true;
            if (!skip && tabPaneElement.id === "bars") {
                for (const batchKey in batchedInBarsSetup) if (batchedInBarsSetup[batchKey].includes(baseLineId)) {skip = true; break;}
            }
            if (!skip && tabPaneElement.id === "stars") {
                for (const batchKey in batchedInStarsSetup) if (batchedInStarsSetup[batchKey].includes(baseLineId)) {skip = true; break;}
            }
            if (skip) return;
            createSliderGroup(`${baseLineId.replace('hex-', '').replace('border-', 'B:').replace('spoke-c-', 'S:' )}:`, `${tabPaneElement.id}-${baseLineId}`, baseLineId, [baseLineId]);
        });
        
        if (tabPaneElement.id === 'test') {
            const testButton = document.createElement('button');
            testButton.className = 'randomize-button';
            testButton.style.width = '100%';
            testButton.style.marginTop = '15px';
            testButton.textContent = 'Test Action';
            tabPaneElement.appendChild(testButton);
        } else if (tabPaneElement.id === 'stars' || tabPaneElement.id === 'bars') {
            const randomizeButton = document.createElement('button');
            randomizeButton.className = 'randomize-button';
            randomizeButton.id = `randomize-${tabPaneElement.id}`;
            randomizeButton.textContent = 'Randomize Tab Settings';
            randomizeButton.style.width = '100%';
            randomizeButton.style.marginTop = '20px';
            randomizeButton.addEventListener('click', () => randomizeTabSettings(tabPaneElement.id)); 
            tabPaneElement.appendChild(randomizeButton);

            const resetButton = document.createElement('button');
            resetButton.className = 'reset-defaults-button'; 
            // Reset button is now global, so removed from here.
        }
    }

    function resetAllSettingsToDefaults() { // Renamed
        console.log('Resetting ALL settings to defaults...');

        // Reset Hexagon Size
        if (hexagonSizeSlider) hexagonSizeSlider.value = defaultHexRadius;
        if (hexagonSizeValueDisplay) hexagonSizeValueDisplay.textContent = defaultHexRadius;
        // Redraw will be called later, which handles applying the size

        currentGlobalLineColor = '#000000';
        updateGlobalLineColor(currentGlobalLineColor); 
        if (globalLineColorSelect) globalLineColorSelect.value = currentGlobalLineColor;
        
        if (presetSelect) presetSelect.value = "none";
        if (presetColorSelect) {
            presetColorSelect.value = "none";
            presetColorSelect.disabled = true;
        }
        currentPresetColorOption = "none";
        updatePresetSelectAppearance("none"); // Reset appearance

        const barsTabButton = document.querySelector('.tab-button[data-tab="bars"]');
        if (barsTabButton) {
            if (!barsTabButton.classList.contains('active')) {
                barsTabButton.click(); 
            } else {
                BASE_LINE_IDS.forEach(baseId => {
                    updateLineLength(baseId, 100);
                    currentLinePercentages[baseId] = 100;
                });
                document.querySelectorAll('input[type="range"][data-base-lineid], input[type="range"][data-batch-type]').forEach(slider => {
                     updateSliderUI(slider, 100);
                });
                // presetSelect and presetColorSelect already set to none above
                saveOmniIndexState(); 
            }
        }
        currentGlobalLineWeight = allowedLineWeights[0]; // Use the first from allowed list
        isLineWeightLocked = true;
        if (globalLineWeightSlider) globalLineWeightSlider.value = currentGlobalLineWeight;
        if (globalLineWeightValueDisplay) globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1); // Ensure display is for the value, not index
        if (lockLineWeightCheckbox) lockLineWeightCheckbox.checked = isLineWeightLocked;
        updateGlobalLineWeight(currentGlobalLineWeight);
        
        currentBackgroundColor = DEFAULT_BACKGROUND_COLOR;
        isBackgroundColorLocked = DEFAULT_BACKGROUND_LOCK;
        if (backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
        if (lockBackgroundColorCheckbox) lockBackgroundColorCheckbox.checked = isBackgroundColorLocked;
        if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
        
        // Set slider to correct index for the currentGlobalLineWeight
        const weightIndex = allowedLineWeights.indexOf(currentGlobalLineWeight);
        if (globalLineWeightSlider) globalLineWeightSlider.value = weightIndex !== -1 ? weightIndex : 0;
        if (globalLineWeightValueDisplay) globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1); // Ensure display is for the value

        // Redraw the grid with the new default size and reset line lengths
        redrawGridAndUpdateControls(defaultHexRadius, false); 
        // Note: redrawGridAndUpdateControls will repopulate tab controls, which will set sliders to 100%
        // and currentLinePercentages will be reset if preserveLengths is false.

        // Ensure the active tab's sliders are visually reset if they weren't by redraw
        // This might be redundant if redrawGridAndUpdateControls correctly resets everything.
        document.querySelectorAll(`#${currentActiveTabId} input[type="range"][data-base-lineid], #${currentActiveTabId} input[type="range"][data-batch-type]`).forEach(slider => {
            updateSliderUI(slider, 100);
        });
        
        saveOmniIndexState(); // Save all reset states
    }

    function redrawGridAndUpdateControls(radius, preserveLengths = false) {
        if (svgContainer) {
            if (!preserveLengths) BASE_LINE_IDS.forEach(id => currentLinePercentages[id] = 100);
            drawHexagonGrid(svgContainer, radius, viewBoxData, currentGlobalLineColor, currentGlobalLineWeight);
            BASE_LINE_IDS.forEach(baseId => updateLineLength(baseId, currentLinePercentages[baseId]));
            ['stars', 'bars'].forEach(tabId => { 
                const tabElement = document.getElementById(tabId);
                if (tabElement) populateLineControlsForTab(tabElement, BASE_LINE_IDS);
            });
        } else console.error('SVG container #omniVisualizationSvg not found!');
    }
    
    function getPresetAccentColor(presetName) {
        return PRESET_ACCENT_COLORS[presetName] || PRESET_ACCENT_COLORS.none;
    }

    function updatePresetSelectAppearance(presetName) {
        if (!presetSelect) return;
        const accentColor = getPresetAccentColor(presetName);
        if (presetName === 'none' || accentColor === PRESET_ACCENT_COLORS.none) {
            presetSelect.style.backgroundColor = DEFAULT_SELECT_BG_COLOR;
            presetSelect.style.color = '#000000';
        } else {
            presetSelect.style.backgroundColor = accentColor;
            presetSelect.style.color = '#000000'; // Ensure black text for contrast
        }
    }

    function applyPresetColorOption(optionValue, activePresetName) {
        currentPresetColorOption = optionValue;
        let newLineEditColor = currentGlobalLineColor;
        let newBgColor = currentBackgroundColor;
        const presetAccent = getPresetAccentColor(activePresetName);

        if (activePresetName === 'none' || optionValue === 'none') {
            // When 'none' is selected for preset color, or if the main preset is 'none',
            // colors are determined by manual controls, not by this function.
            // The UI for presetColorSelect should be set to 'none' by the caller.
            return;
        }

        switch (optionValue) {
            case 'color-on-white': newLineEditColor = presetAccent; newBgColor = GREY_COLORS.white; break;
            case 'light-grey-on-white': newLineEditColor = GREY_COLORS.light; newBgColor = GREY_COLORS.white; break;
            case 'medium-grey-on-white': newLineEditColor = GREY_COLORS.medium; newBgColor = GREY_COLORS.white; break;
            case 'black-on-white': newLineEditColor = GREY_COLORS.black; newBgColor = GREY_COLORS.white; break;
            case 'black-on-color': newLineEditColor = GREY_COLORS.black; newBgColor = presetAccent; break;
            case 'color-on-black': newLineEditColor = presetAccent; newBgColor = GREY_COLORS.black; break;
            case 'color-on-light-grey': newLineEditColor = presetAccent; newBgColor = GREY_COLORS.light; break;
            case 'black-on-light-grey': newLineEditColor = GREY_COLORS.black; newBgColor = GREY_COLORS.light; break;
            case 'medium-grey-on-light-grey': newLineEditColor = GREY_COLORS.medium; newBgColor = GREY_COLORS.light; break;
            case 'color-on-medium-grey': newLineEditColor = presetAccent; newBgColor = GREY_COLORS.medium; break;
            case 'black-on-medium-grey': newLineEditColor = GREY_COLORS.black; newBgColor = GREY_COLORS.medium; break;
            case 'light-grey-on-medium-grey': newLineEditColor = GREY_COLORS.light; newBgColor = GREY_COLORS.medium; break;
        }

        if (!isLineColorLocked) {
            currentGlobalLineColor = newLineEditColor;
            if (globalLineColorSelect) globalLineColorSelect.value = currentGlobalLineColor;
            updateGlobalLineColor(currentGlobalLineColor);
        }
        if (!isBackgroundColorLocked) {
            currentBackgroundColor = newBgColor;
            if (backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
            if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
        }
    }

   function applyPreset(presetName) {
        if (presetName === "none") {
            // If preset is set to 'none' (e.g. by manual control change),
            // ensure presetColorSelect also goes to 'none' and is disabled.
            if (presetColorSelect) {
                presetColorSelect.value = "none";
                presetColorSelect.disabled = true;
            }
            currentPresetColorOption = "none";
            updatePresetSelectAppearance("none"); // Update main preset dropdown style
            // Don't apply any further preset logic. Colors/lengths are now manual.
            saveOmniIndexState();
            return;
        }

        // A specific preset is chosen
        if (presetColorSelect) presetColorSelect.disabled = false; // Enable it
        currentGlobalLineWeight = allowedLineWeights[0]; // Default to 1.0 for presets
        updateGlobalLineWeight(currentGlobalLineWeight);
        const weightIndexForPreset = allowedLineWeights.indexOf(currentGlobalLineWeight);
        if (globalLineWeightSlider) globalLineWeightSlider.value = weightIndexForPreset !== -1 ? weightIndexForPreset : 0; 
        if (globalLineWeightValueDisplay) globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
        isLineWeightLocked = false; if (lockLineWeightCheckbox) lockLineWeightCheckbox.checked = false;
        
        // Set default preset color option and apply it
        if (presetColorSelect) presetColorSelect.value = 'color-on-white';
        applyPresetColorOption('color-on-white', presetName); // This handles line and bg color based on locks

        // Applying a preset also unlocks line color and background color by default
        isLineColorLocked = false; if (lockLineColorCheckbox) lockLineColorCheckbox.checked = false;
        isBackgroundColorLocked = false; if (lockBackgroundColorCheckbox) lockBackgroundColorCheckbox.checked = false;


        const barsTabButton = document.querySelector('.tab-button[data-tab="bars"]');
        let isBarsActive = barsTabButton.classList.contains('active');
        if (barsTabButton && !isBarsActive) barsTabButton.click(); 

        setTimeout(() => {
            const borderLines = BASE_LINE_IDS.filter(id => id.startsWith("border-"));
            setBatchLines(borderLines, 75, document.getElementById(`slider-bars-batch-border`));
            const starsBorderBatchSlider = document.getElementById(`slider-stars-batch-border`);
            if (starsBorderBatchSlider) updateSliderUI(starsBorderBatchSlider, 75);
            
            const targetBarsBatchPercentages = {}; 
            // Preset accent color is now handled by applyPresetColorOption, so no need for colorToApply here
            // Update the appearance of the presetSelect dropdown itself
            updatePresetSelectAppearance(presetName);

            switch (presetName) {
                case "egnyte": targetBarsBatchPercentages["vertical-spokes"] = 75; targetBarsBatchPercentages["horizontal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-corner-spokes"] = 75; break;
                case "aec": targetBarsBatchPercentages["vertical-spokes"] = 75; targetBarsBatchPercentages["horizontal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-corner-spokes"] = 75; break;
                case "financial":  targetBarsBatchPercentages["vertical-spokes"] = 75; targetBarsBatchPercentages["horizontal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-corner-spokes"] = 0; break;
                case "lifesciences": targetBarsBatchPercentages["vertical-spokes"] = 0; targetBarsBatchPercentages["horizontal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-corner-spokes"] = 0; break;
                case "channel":  targetBarsBatchPercentages["vertical-spokes"] = 0; targetBarsBatchPercentages["horizontal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-corner-spokes"] = 75; break;
                case "media":  targetBarsBatchPercentages["vertical-spokes"] = 0; targetBarsBatchPercentages["horizontal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-corner-spokes"] = 0; break;
            }
            
            for (const batchKey in batchedInBarsSetup) { 
                if (targetBarsBatchPercentages.hasOwnProperty(batchKey)) {
                    const linesInBatch = batchedInBarsSetup[batchKey];
                    const percentage = targetBarsBatchPercentages[batchKey];
                    const batchSliderElement = document.getElementById(`slider-bars-batch-${batchKey}`);
                    setBatchLines(linesInBatch, percentage, batchSliderElement);
                }
            }
            saveOmniIndexState(); // Save after all preset changes are applied
        }, isBarsActive ? 10 : 50); 
    }

    const randomPercentageMap = [0, 25, 50, 75];
    function getRandomPercentage() { return randomPercentageMap[Math.floor(Math.random() * randomPercentageMap.length)]; }

    function randomizeTabSettings(tabId) {
        if (presetSelect) presetSelect.value = "none";
        if (presetColorSelect) {
            presetColorSelect.value = "none";
            presetColorSelect.disabled = true;
        }
        currentPresetColorOption = "none";
        updatePresetSelectAppearance("none"); // Reset appearance

        if (!isBackgroundColorLocked) {
            // Randomize background or set to default? Let's set to default for now.
            currentBackgroundColor = DEFAULT_BACKGROUND_COLOR; 
            if (backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
            if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
        }

        const relevantBatchSetup = (tabId === "stars") ? batchedInStarsSetup : batchedInBarsSetup;
        const borderPercentage = getRandomPercentage();
        const borderLines = BASE_LINE_IDS.filter(id => id.startsWith("border-"));
        const borderBatchSlider = document.getElementById(`slider-${tabId}-batch-border`);
        setBatchLines(borderLines, borderPercentage, borderBatchSlider);
        for (const batchKey in relevantBatchSetup) {
            const batchPercentage = getRandomPercentage();
            const linesInBatch = relevantBatchSetup[batchKey];
            const batchSlider = document.getElementById(`slider-${tabId}-batch-${batchKey}`);
            setBatchLines(linesInBatch, batchPercentage, batchSlider);
        }
        if (tabId === "stars") {
            BASE_LINE_IDS.forEach(baseLineId => {
                let isBatched = baseLineId.startsWith("border-");
                for (const batchKey in batchedInStarsSetup) if (batchedInStarsSetup[batchKey].includes(baseLineId)) { isBatched = true; break; }
                if (!isBatched) {
                    const individualPercentage = getRandomPercentage();
                    updateLineLength(baseLineId, individualPercentage);
                    currentLinePercentages[baseLineId] = individualPercentage;
                    const indSlider = document.getElementById(`slider-stars-${baseLineId}`);
                    updateSliderUI(indSlider, individualPercentage);
                }
            });
        }
        if (!isLineColorLocked) {
            const colorOptions = globalLineColorSelect.options;
            const randomColorIndex = Math.floor(Math.random() * colorOptions.length);
            currentGlobalLineColor = colorOptions[randomColorIndex].value;
            updateGlobalLineColor(currentGlobalLineColor);
            globalLineColorSelect.value = currentGlobalLineColor;
        }
        if (!isLineWeightLocked) {
            const randomIndex = Math.floor(Math.random() * allowedLineWeights.length);
            currentGlobalLineWeight = allowedLineWeights[randomIndex];
            updateGlobalLineWeight(currentGlobalLineWeight);
            globalLineWeightSlider.value = randomIndex;
            globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
        }
        saveOmniIndexState(); // Save state after randomizing
    }

    function saveOmniIndexState() {
        const state = {
            currentGlobalLineColor, currentGlobalLineWeight, isLineColorLocked, isLineWeightLocked,
            currentBackgroundColor, isBackgroundColorLocked,
            currentPresetColorOption, 
            isCustomizerExpanded, // Save customizer state
            currentActiveTabId: document.querySelector('.tab-button.active')?.dataset.tab || 'bars',
            currentLinePercentages: { ...currentLinePercentages }, 
            hexagonSize: parseInt(hexagonSizeSlider.value, 10),
            presetValue: presetSelect.value,
            presetColorValue: presetColorSelect.value 
        };
        localStorage.setItem(OMNI_INDEX_STATE_KEY, JSON.stringify(state));
        console.log('Omni Index state saved:', state);
    }

    function loadOmniIndexState() {
        const savedStateString = localStorage.getItem(OMNI_INDEX_STATE_KEY);
        if (savedStateString) {
            try {
                const savedState = JSON.parse(savedStateString);
                console.log('Omni Index state loaded:', savedState);
                currentGlobalLineColor = savedState.currentGlobalLineColor || '#000000';
                let loadedWeight = savedState.hasOwnProperty('currentGlobalLineWeight') ? savedState.currentGlobalLineWeight : allowedLineWeights[0];
                if (!allowedLineWeights.includes(loadedWeight)) {
                    loadedWeight = allowedLineWeights[0]; // Default to 1.0 if saved weight is invalid
                }
                currentGlobalLineWeight = loadedWeight;
                isLineColorLocked = savedState.isLineColorLocked || false;
                isLineWeightLocked = savedState.hasOwnProperty('isLineWeightLocked') ? savedState.isLineWeightLocked : true;
                
                currentBackgroundColor = savedState.currentBackgroundColor || DEFAULT_BACKGROUND_COLOR;
                isBackgroundColorLocked = savedState.hasOwnProperty('isBackgroundColorLocked') ? savedState.isBackgroundColorLocked : DEFAULT_BACKGROUND_LOCK;
                
                currentPresetColorOption = savedState.currentPresetColorOption || DEFAULT_PRESET_COLOR_OPTION;
                isCustomizerExpanded = savedState.hasOwnProperty('isCustomizerExpanded') ? savedState.isCustomizerExpanded : false;
                let loadedPresetValue = savedState.presetValue || 'none';
                let loadedPresetColorValue = savedState.presetColorValue || 'none';

                currentActiveTabId = savedState.currentActiveTabId || 'bars';
                
                // Ensure currentLinePercentages is properly initialized before assigning from savedState
                BASE_LINE_IDS.forEach(id => { 
                    currentLinePercentages[id] = (savedState.currentLinePercentages && typeof savedState.currentLinePercentages === 'object' && savedState.currentLinePercentages.hasOwnProperty(id)) 
                                                ? savedState.currentLinePercentages[id] 
                                                : 100;
                });
                // The Object.assign was removed as the loop above handles it more safely.

                hexagonSizeSlider.value = savedState.hexagonSize || defaultHexRadius;
                hexagonSizeValueDisplay.textContent = hexagonSizeSlider.value;
                
                globalLineColorSelect.value = currentGlobalLineColor;
                lockLineColorCheckbox.checked = isLineColorLocked;
                
                const loadedWeightIndex = allowedLineWeights.indexOf(currentGlobalLineWeight);
                globalLineWeightSlider.value = loadedWeightIndex !== -1 ? loadedWeightIndex : 0;
                globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
                
                lockLineWeightCheckbox.checked = isLineWeightLocked;
                
                if (backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
                if (lockBackgroundColorCheckbox) lockBackgroundColorCheckbox.checked = isBackgroundColorLocked;
                if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
                
                if (presetSelect) presetSelect.value = loadedPresetValue;
                if (presetColorSelect) {
                    presetColorSelect.value = loadedPresetColorValue;
                    presetColorSelect.disabled = (loadedPresetValue === 'none');
                }
                
                updatePresetSelectAppearance(loadedPresetValue); // Update style of presetSelect

                // If a preset was loaded, re-apply its color option logic
                // This ensures consistency if locks were changed or state was manually edited
                if (loadedPresetValue !== 'none' && loadedPresetColorValue !== 'none') {
                    applyPresetColorOption(loadedPresetColorValue, loadedPresetValue);
                }

                // Apply customizer expanded state
                if (customizerContent && customizerSection) {
                    if (isCustomizerExpanded) {
                        customizerContent.style.display = 'block';
                        customizerSection.classList.add('expanded');
                    } else {
                        customizerContent.style.display = 'none';
                        customizerSection.classList.remove('expanded');
                    }
                }


                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanes.forEach(pane => pane.classList.remove('active'));
                const tabToActivate = document.querySelector(`.tab-button[data-tab="${currentActiveTabId}"]`);
                if (tabToActivate) tabToActivate.classList.add('active');
                const paneToActivate = document.getElementById(currentActiveTabId);
                if (paneToActivate) paneToActivate.classList.add('active');
                
                redrawGridAndUpdateControls(parseInt(hexagonSizeSlider.value, 10), true); 
                return true;
            } catch (e) { console.error('Error loading Omni Index state:', e); }
        }
        return false; 
    }

    document.addEventListener('DOMContentLoaded', () => {
        if (!loadOmniIndexState()) { // Apply defaults if no saved state or loading failed
            hexagonSizeSlider.value = defaultHexRadius; 
            hexagonSizeValueDisplay.textContent = defaultHexRadius;
            BASE_LINE_IDS.forEach(id => currentLinePercentages[id] = 100); 
            currentGlobalLineColor = '#000000'; 
            currentGlobalLineWeight = allowedLineWeights[0]; // Default to 1.0
            currentBackgroundColor = DEFAULT_BACKGROUND_COLOR;
            currentPresetColorOption = DEFAULT_PRESET_COLOR_OPTION;
            isCustomizerExpanded = false; // Default to collapsed
            isLineColorLocked = false; 
            isLineWeightLocked = true; 
            isBackgroundColorLocked = DEFAULT_BACKGROUND_LOCK;
            currentActiveTabId = 'bars';

            if(globalLineColorSelect) globalLineColorSelect.value = currentGlobalLineColor;
            if(lockLineColorCheckbox) lockLineColorCheckbox.checked = isLineColorLocked;
            
            const defaultWeightIndex = allowedLineWeights.indexOf(currentGlobalLineWeight);
            if(globalLineWeightSlider) globalLineWeightSlider.value = defaultWeightIndex !== -1 ? defaultWeightIndex : 0;
            if(globalLineWeightValueDisplay) globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
            if(lockLineWeightCheckbox) lockLineWeightCheckbox.checked = isLineWeightLocked;

            if(backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
            if(lockBackgroundColorCheckbox) lockBackgroundColorCheckbox.checked = isBackgroundColorLocked;
            if(svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
            
            if(presetSelect) presetSelect.value = 'none';
            if(presetColorSelect) {
                presetColorSelect.value = 'none';
                presetColorSelect.disabled = true;
            }
            updatePresetSelectAppearance('none'); // Set initial style for presetSelect
            
            // Set initial customizer state (collapsed)
            if (customizerContent && customizerSection) {
                customizerContent.style.display = 'none';
                customizerSection.classList.remove('expanded');
            }


            document.querySelector('.tab-button[data-tab="bars"]')?.classList.add('active');
            const barsPane = document.getElementById('bars'); if (barsPane) barsPane.classList.add('active');
            document.querySelector('.tab-button[data-tab="stars"]')?.classList.remove('active');
            const starsPane = document.getElementById('stars'); if (starsPane) starsPane.classList.remove('active');
            redrawGridAndUpdateControls(defaultHexRadius, false); 
        }
        hexagonSizeSlider.addEventListener('input', function() {
            const newRadius = parseInt(this.value);
            hexagonSizeValueDisplay.textContent = newRadius;
            redrawGridAndUpdateControls(newRadius, true); 
            if (presetSelect.value !== "none") {
                presetSelect.value = "none";
                if (presetColorSelect) {
                    presetColorSelect.value = "none";
                    presetColorSelect.disabled = true;
                }
                currentPresetColorOption = "none";
                updatePresetSelectAppearance("none");
            }
            saveOmniIndexState();
        });
        globalLineColorSelect.addEventListener('change', function() {
            currentGlobalLineColor = this.value;
            updateGlobalLineColor(currentGlobalLineColor);
            if (presetSelect.value !== "none") {
                presetSelect.value = "none";
                if (presetColorSelect) {
                    presetColorSelect.value = "none";
                    presetColorSelect.disabled = true;
                }
                currentPresetColorOption = "none";
                updatePresetSelectAppearance("none");
            }
            saveOmniIndexState();
        });
        lockLineColorCheckbox.addEventListener('change', function() { 
            isLineColorLocked = this.checked; 
            // If unchecking while a preset color option is active, the color might change
            if (!isLineColorLocked && presetSelect.value !== 'none' && presetColorSelect.value !== 'none') {
                 applyPresetColorOption(presetColorSelect.value, presetSelect.value);
            }
            saveOmniIndexState();
        });
        globalLineWeightSlider.addEventListener('input', function() {
            const selectedIndex = parseInt(this.value);
            currentGlobalLineWeight = allowedLineWeights[selectedIndex];
            globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
            updateGlobalLineWeight(currentGlobalLineWeight);
            // Presets are NOT reset when only line weight changes.
            saveOmniIndexState();
        });
        lockLineWeightCheckbox.addEventListener('change', function() { 
            isLineWeightLocked = this.checked; 
            saveOmniIndexState();
        });
        backgroundColorSelect.addEventListener('change', function() {
            currentBackgroundColor = this.value;
            if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
            if (presetSelect.value !== "none") {
                presetSelect.value = "none";
                if (presetColorSelect) {
                    presetColorSelect.value = "none";
                    presetColorSelect.disabled = true;
                }
                currentPresetColorOption = "none";
                updatePresetSelectAppearance("none");
            }
            saveOmniIndexState();
        });
        lockBackgroundColorCheckbox.addEventListener('change', function() {
            isBackgroundColorLocked = this.checked;
            if (!isBackgroundColorLocked && presetSelect.value !== 'none' && presetColorSelect.value !== 'none') {
                 applyPresetColorOption(presetColorSelect.value, presetSelect.value);
            }
            saveOmniIndexState();
        });
        presetSelect.addEventListener('change', function() {
            const selectedPresetValue = this.value;
            applyPreset(selectedPresetValue); // applyPreset handles enabling/disabling presetColorSelect internally
                                              // and also sets its default value if a preset is chosen.
            // Explicitly ensure disabled state if "none" is chosen for presetSelect
            if (selectedPresetValue === 'none' && presetColorSelect) {
                 presetColorSelect.disabled = true;
                 presetColorSelect.value = 'none'; // Also reset its value
                 currentPresetColorOption = 'none';
            }
            saveOmniIndexState(); 
        });
        presetColorSelect.addEventListener('change', function() {
            const selectedPreset = presetSelect.value;
            if (selectedPreset !== 'none') {
                applyPresetColorOption(this.value, selectedPreset);
            } else {
                // This case should ideally not be reachable if presetColorSelect is disabled
                // when presetSelect is 'none'. But as a safeguard:
                this.value = 'none'; 
                currentPresetColorOption = 'none';
            }
            saveOmniIndexState();
        });

        const manipulatorLink = document.getElementById('manipulatorLink');
        if (manipulatorLink) manipulatorLink.addEventListener('click', () => saveOmniIndexState());
        const animatorLink = document.getElementById('animatorLink');
        // if (animatorLink) animatorLink.addEventListener('click', () => saveOmniIndexState()); // Animator link removed
        
        const resetAllButton = document.getElementById('resetAllSettingsButton');
        if (resetAllButton) resetAllButton.addEventListener('click', resetAllSettingsToDefaults);

        if (customizerHeader && customizerContent && customizerSection) {
            customizerHeader.addEventListener('click', () => {
                isCustomizerExpanded = !isCustomizerExpanded;
                if (isCustomizerExpanded) {
                    customizerContent.style.display = 'block';
                    customizerSection.classList.add('expanded');
                } else {
                    customizerContent.style.display = 'none';
                    customizerSection.classList.remove('expanded');
                }
                saveOmniIndexState(); // Save the new expanded/collapsed state
            });
        }

        const downloadButton = document.getElementById('downloadSvgButton');
        if (downloadButton) downloadButton.addEventListener('click', handleSvgDownload);
    });

    function handleSvgDownload() {
        const numHexagonsWide = parseInt(document.getElementById('hexagonsWideInput').value) || 1;
        const numHexagonsTall = parseInt(document.getElementById('hexagonsTallInput').value) || 1;
        
        const currentHexRadius = parseInt(hexagonSizeSlider.value);
        // Use currentGlobalLineColor and currentBackgroundColor for accuracy
        const finalGlobalStrokeColor = currentGlobalLineColor; 
        const finalBackgroundColor = currentBackgroundColor;
        
        // globalLineWeightSlider stores index, currentGlobalLineWeight has the actual value
        const finalGlobalStrokeWeight = currentGlobalLineWeight; 
        
        console.log(`Downloading SVG: ${numHexagonsWide}x${numHexagonsTall}, R=${currentHexRadius}, LineColor=${finalGlobalStrokeColor}, BGColor=${finalBackgroundColor}, Weight=${finalGlobalStrokeWeight}`);

        const R = currentHexRadius;
        const hexGridItemWidth = R * Math.sqrt(3); 
        const hexGridItemHeight = R * 2;         
        const horizSpacing = hexGridItemWidth;
        const vertSpacing = hexGridItemHeight * 0.75; 

        const padding = R * 0.25; 
        let totalSvgWidth = padding * 2;
        if (numHexagonsWide > 0) {
            totalSvgWidth += (numHexagonsWide - 1) * horizSpacing + hexGridItemWidth;
            if (numHexagonsTall > 1 && numHexagonsWide > 0) { 
                totalSvgWidth = Math.max(totalSvgWidth, ((numHexagonsWide - 0.5) * horizSpacing) + hexGridItemWidth );
            }
        }
        
        let totalSvgHeight = padding * 2;
        if (numHexagonsTall > 0) {
            totalSvgHeight += (numHexagonsTall - 1) * vertSpacing + hexGridItemHeight;
        }
        
        let svgElements = '';

        const templateLines = [];
        if (svgContainer) { 
            const linesInOnScreenSvg = svgContainer.querySelectorAll('line');
            linesInOnScreenSvg.forEach(line => {
                const x1 = parseFloat(line.getAttribute('x1'));
                const y1 = parseFloat(line.getAttribute('y1'));
                const x2 = parseFloat(line.getAttribute('x2'));
                const y2 = parseFloat(line.getAttribute('y2'));
                const sw = parseFloat(line.getAttribute('stroke-width'));
                const opacity = line.getAttribute('stroke-opacity');
                const displayStyle = window.getComputedStyle(line).display;

                if (sw > 0 && 
                    (opacity === null || opacity !== '0') && 
                    displayStyle !== 'none' &&
                    (Math.abs(x1 - x2) > 0.001 || Math.abs(y1 - y2) > 0.001) // Check for non-zero-length lines with a tolerance
                ) {
                    templateLines.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
                }
            });
        }

        if (templateLines.length === 0) {
            console.warn("No visible, non-zero-length lines found in the on-screen SVG to use as a template for download.");
        }
        
        for (let row = 0; row < numHexagonsTall; row++) {
            for (let col = 0; col < numHexagonsWide; col++) {
                const offsetX = col * horizSpacing + (row % 2 === 1 ? horizSpacing / 2 : 0);
                const offsetY = row * vertSpacing;
                
                const groupTranslateX = padding + offsetX + (R * Math.sqrt(3) / 2); 
                const groupTranslateY = padding + offsetY + R;    

                let groupContent = `<g transform="translate(${groupTranslateX.toFixed(3)}, ${groupTranslateY.toFixed(3)})">\n`;

                templateLines.forEach(lineDef => {
                    // Use finalGlobalStrokeColor and finalGlobalStrokeWeight
                    groupContent += `  <line x1="${lineDef.x1}" y1="${lineDef.y1}" x2="${lineDef.x2}" y2="${lineDef.y2}" stroke="${finalGlobalStrokeColor}" stroke-width="${finalGlobalStrokeWeight}" stroke-linecap="round" />\n`;
                });
                groupContent += `</g>\n`;
                svgElements += groupContent;
            }
        }
        
        // Add background rectangle
        const backgroundRect = `<rect width="${totalSvgWidth.toFixed(3)}" height="${totalSvgHeight.toFixed(3)}" fill="${finalBackgroundColor}" />\n`;
        const finalSvgString = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg width="${totalSvgWidth.toFixed(3)}" height="${totalSvgHeight.toFixed(3)}" viewBox="0 0 ${totalSvgWidth.toFixed(3)} ${totalSvgHeight.toFixed(3)}" xmlns="http://www.w3.org/2000/svg">\n${backgroundRect}${svgElements}</svg>`;

        const blob = new Blob([finalSvgString], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `hexagon_pattern_grid_${numHexagonsWide}x${numHexagonsTall}.svg`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
