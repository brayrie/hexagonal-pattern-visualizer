<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Omni Visualizer</title>
  <link rel="stylesheet" href="css/fonts.css">
  <link rel="stylesheet" href="css/omni-style.css">
</head>
<body>
  <div class="control-panel">
    <h2>Pattern</h2>
    
    <div class="page-toggler">
      <a href="index.html" class="page-toggle-button active">Pattern</a>
      <a href="manipulator.html" id="manipulatorLink" class="page-toggle-button">Globe</a>
      <a href="globe_spin_geo.html" id="globeSpinGeoLink" class="page-toggle-button">Globe Spin Geo</a>
    </div>

    <!-- Global Hexagon Size Control -->
    <div class="background-control" style="margin-top: 15px;">
      <div class="slider-container">
        <label for="zoomSlider" style="min-width: 100px;">Zoom:</label>
        <input type="range" id="zoomSlider" min="0.5" max="2.0" value="1.0" step="0.1">
        <span id="zoomValue" class="value-display" style="min-width: 40px;">1.0x</span>
      </div>
    </div>

    <!-- Preset Selector -->
    <div class="background-control">
        <div class="slider-container">
            <label for="presetSelect" style="min-width: 100px;">Preset:</label>
            <select id="presetSelect" class="color-select" style="flex-grow: 1; margin-bottom: 5px;">
                <option value="none">None</option>
                <option value="egnyte">Egnyte</option>
                <option value="aec">AEC</option>
                <option value="financial">Financial Services</option>
                <option value="lifesciences">Life Sciences</option>
                <option value="channel">Channel Partners</option>
                <option value="media">Media & Entertainment</option>
            </select>
        </div>
        <div class="slider-container" style="margin-top: 0px;">
            <label for="presetColorSelect" style="min-width: 100px;">Preset Color:</label>
            <select id="presetColorSelect" class="color-select" style="flex-grow: 1;">
                <option value="none">None</option>
                <option value="color-on-white">Color on White</option>
                <option value="light-grey-on-white">Light Grey on White</option>
                <option value="medium-grey-on-white">Medium Grey on White</option>
                <option value="black-on-white">Black on White</option>
                <option value="black-on-color">Black on Color</option>
                <option value="color-on-black">Color on Black</option>
                <option value="color-on-light-grey">Color on Light Grey</option>
                <option value="black-on-light-grey">Black on Light Grey</option>
                <option value="medium-grey-on-light-grey">Medium Grey on Light Grey</option>
                <option value="color-on-medium-grey">Color on Medium Grey</option>
                <option value="black-on-medium-grey">Black on Medium Grey</option>
                <option value="light-grey-on-medium-grey">Light Grey on Medium Grey</option>
            </select>
        </div>
    </div>

    <!-- Line Weight Control -->
    <div class="background-control">
      <div class="slider-container">
        <label for="globalLineWeightSlider" style="min-width: 100px;">Line Weight:</label>
        <input type="range" id="globalLineWeightSlider" min="0" max="3" value="0" step="1" style="flex-grow: 1;">
        <span id="globalLineWeightValue" class="value-display" style="min-width: 40px;">1.0</span>
      </div>
      <div class="checkbox-container" style="margin-top: 5px;">
        <label for="lockLineWeight">Lock Weight:</label>
        <input type="checkbox" id="lockLineWeight" checked>
      </div>
    </div>

    <!-- Customizer Section -->
    <div class="background-control customizer-section" id="customizerSection"> <!-- Added ID -->
      <h4 style="margin-bottom: 10px; margin-top:0px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;" id="customizerHeader">
        Customizer
        <span class="customizer-arrow">&#9654;</span>
      </h4>
      <div id="customizerContent" style="display: none;"> <!-- Content wrapper, collapsed by default -->
        <!-- Color Controls (now inside Customizer) -->
        <div style="padding-bottom: 10px;"> 
          <h5 style="margin-bottom: 10px; margin-top:0px; font-size: 0.95em;">Color Controls</h5>
          <div class="slider-container"> 
            <label for="globalLineColorSelect" style="min-width: 100px;">Line Color:</label>
          <select id="globalLineColorSelect" class="color-select" style="flex-grow: 1;">
            <option value="#000000">Black</option>
            <option value="#F0F5F7">Light Grey</option>
            <option value="#B6C0C4">Medium Grey</option>
            <option value="#0BC5BA">Egnyte Teal</option>
            <option value="#FF6640">AEC Orange</option>
            <option value="#DA9DFF">Financial Purple</option>
            <option value="#359DFF">LifeSci Blue</option>
            <option value="#85E961">Channel Green</option>
            <option value="#FF51B6">Media Pink</option>
          </select>
        </div>
        <div class="checkbox-container" style="margin-top: 5px; margin-bottom: 10px;">
          <label for="lockLineColor">Lock Color:</label>
          <input type="checkbox" id="lockLineColor">
        </div>

        <!-- Background Color Control -->
        <div class="slider-container" style="margin-top: 10px;">
          <label for="backgroundColorSelect" style="min-width: 100px;">Background:</label>
          <select id="backgroundColorSelect" class="color-select" style="flex-grow: 1;">
            <option value="#FFFFFF">White</option>
            <option value="#F0F5F7">Light Grey</option>
            <option value="#B6C0C4">Medium Grey</option>
            <option value="#000000">Black</option>
            <option value="#0BC5BA">Egnyte Teal</option>
            <option value="#FF6640">AEC Orange</option>
            <option value="#DA9DFF">Financial Purple</option>
            <option value="#359DFF">LifeSci Blue</option>
            <option value="#85E961">Channel Green</option>
            <option value="#FF51B6">Media Pink</option>
          </select>
        </div>
        <div class="checkbox-container" style="margin-top: 5px; margin-bottom: 10px;">
          <label for="lockBackgroundColor">Lock Background:</label>
          <input type="checkbox" id="lockBackgroundColor">
        </div>
      </div>

      <!-- Line Length Controls Sub-section (inside Customizer) -->
      <div style="padding-top: 15px; margin-top:15px; border-top: 1px solid #dee2e6;"> <!-- Plain div with top border for separation -->
        <h5 style="margin-bottom: 10px; margin-top:0px; font-size: 0.95em;">Line Length Controls</h5>
        <!-- Tab Navigation -->
        <div class="tab-navigation">
          <button class="tab-button active" data-tab="bars">Bars</button>
          <button class="tab-button" data-tab="stars">Stars</button>
        </div>

        <!-- Tab Content -->
        <div class="tab-content">
          <div id="bars" class="tab-pane active">
            <h4 style="display:none;">Bars Controls</h4> <!-- Hide original H4 if sub-section has title -->
            <!-- Content generated by JS -->
          </div>
          <div id="stars" class="tab-pane">
            <h4 style="display:none;">Stars Controls</h4> <!-- Hide original H4 if sub-section has title -->
            <!-- Content generated by JS -->
          </div>
          <!-- Test tab content removed -->
        </div>
      </div>
    </div> <!-- End of customizerContent -->
    </div> <!-- End of customizerSection -->

    <!-- Reset Settings Button -->
    <div class="background-control" style="margin-top: 10px;">
        <button id="resetAllSettingsButton" class="reset-defaults-button" style="width: 100%;">Reset Settings</button>
    </div>
    
    <!-- SVG Download Section -->
    <div class="background-control" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ccc;">
      <h4 style="margin-bottom: 10px;">SVG Download</h4>
      <div class="slider-container" style="margin-bottom: 5px;">
        <label for="hexagonsWideInput" style="min-width: 120px;">Hexagons Wide:</label>
        <input type="number" id="hexagonsWideInput" value="10" min="1" style="width: 60px; text-align: right; margin-right: 5px;">
      </div>
      <div class="slider-container" style="margin-bottom: 10px;">
        <label for="hexagonsTallInput" style="min-width: 120px;">Hexagons Tall:</label>
        <input type="number" id="hexagonsTallInput" value="7" min="1" style="width: 60px; text-align: right; margin-right: 5px;">
      </div>
      <button id="downloadSvgButton" class="randomize-button" style="width: 100%;">Download SVG</button>
    </div>

  </div>
  
  <div class="visualization-panel">
    <svg id="omniVisualizationSvg" class="pattern-display-area" width="100%" height="100%" viewBox="-400 -300 800 600" style="max-width: 800px; max-height: 600px;"></svg>
  </div>
  
  <script type="module">
    import { drawHexagonGrid, updateLineLength, BASE_LINE_IDS, updateGlobalLineColor, updateGlobalLineWeight } from './js/omniHexagon.js';

    const OMNI_INDEX_STATE_KEY = 'omniIndexState';
    const FIXED_HEX_RADIUS = 75; // Renamed, actual hexagon size is fixed
    const initialViewBox = { x: -400, y: -300, width: 800, height: 600 }; // Used as base for 1.0x zoom
    const svgContainer = document.getElementById('omniVisualizationSvg');
    const zoomSlider = document.getElementById('zoomSlider'); // Renamed
    const zoomValueDisplay = document.getElementById('zoomValue'); // Renamed
    const globalLineColorSelect = document.getElementById('globalLineColorSelect');
    const lockLineColorCheckbox = document.getElementById('lockLineColor'); 
    const globalLineWeightSlider = document.getElementById('globalLineWeightSlider');
    const globalLineWeightValueDisplay = document.getElementById('globalLineWeightValue');
    const lockLineWeightCheckbox = document.getElementById('lockLineWeight'); 
    const presetSelect = document.getElementById('presetSelect');
    const presetColorSelect = document.getElementById('presetColorSelect'); // New
    const backgroundColorSelect = document.getElementById('backgroundColorSelect');
    const lockBackgroundColorCheckbox = document.getElementById('lockBackgroundColor');
    // const visualizationPanel = document.querySelector('.visualization-panel'); // No longer needed for BG color

    const PRESET_ACCENT_COLORS = {
        "egnyte": "#0BC5BA",
        "aec": "#FF6640",
        "financial": "#DA9DFF",
        "lifesciences": "#359DFF",
        "channel": "#85E961",
        "media": "#FF51B6",
        "none": "#000000" // Default for 'none' preset
    };

    const GREY_COLORS = {
        light: '#F0F5F7',
        medium: '#B6C0C4',
        white: '#FFFFFF',
        black: '#000000'
    };

    const allowedLineWeights = [1, 1.5, 2.5, 4];
    const DEFAULT_BACKGROUND_COLOR = '#FFFFFF';
    const DEFAULT_BACKGROUND_LOCK = false;
    const DEFAULT_PRESET_COLOR_OPTION = 'none';
    const CUSTOMIZER_STATE_KEY = 'omniCustomizerState'; // For local storage of expand/collapse
    const DEFAULT_SELECT_BG_COLOR = '#F0F5F7'; // Match other inputs
    
    let currentGlobalLineColor = '#000000'; 
    let currentGlobalLineWeight = allowedLineWeights[0]; // Default to 1.0
    let currentBackgroundColor = DEFAULT_BACKGROUND_COLOR;
    let currentPresetColorOption = DEFAULT_PRESET_COLOR_OPTION;
    let isLineColorLocked = false; 
    let isLineWeightLocked = true; 
    let isBackgroundColorLocked = DEFAULT_BACKGROUND_LOCK;
    let isCustomizerExpanded = false; // Default to collapsed
    let currentActiveTabId = 'bars';
    let currentZoom = 1.0; // Added for zoom state

    const customizerHeader = document.getElementById('customizerHeader');
    const customizerContent = document.getElementById('customizerContent');
    const customizerSection = document.getElementById('customizerSection');


    const tabButtons = document.querySelectorAll('.tab-button');
    const tabPanes = document.querySelectorAll('.tab-content .tab-pane');

    const currentLinePercentages = {};
    BASE_LINE_IDS.forEach(id => currentLinePercentages[id] = 100); 

    const percentageMap = [0, 25, 50, 75, 100]; 

    const batchedInBarsSetup = {
        "vertical-spokes": ["spoke-c-p6", "spoke-c-p12"],
        "horizontal-edge-spokes": ["spoke-c-p3", "spoke-c-p9"],
        "diagonal-edge-spokes": ["spoke-c-p1", "spoke-c-p5", "spoke-c-p7", "spoke-c-p11"],
        "diagonal-corner-spokes": ["spoke-c-p2", "spoke-c-p4", "spoke-c-p8", "spoke-c-p10"]
    };
    
    const batchedInStarsSetup = {
        "y-batch": ["spoke-c-p2", "spoke-c-p6", "spoke-c-p10"],
        "a-batch": ["spoke-c-p12", "spoke-c-p4", "spoke-c-p8"],
        "x-batch": ["spoke-c-p3", "spoke-c-p9", "spoke-c-p1", "spoke-c-p5", "spoke-c-p7", "spoke-c-p11"]
    };

    function updateSliderUI(sliderElement, percentage) {
        if (sliderElement) {
            const sliderValueIndex = percentageMap.indexOf(percentage);
            sliderElement.value = sliderValueIndex !== -1 ? sliderValueIndex : 4; 
            const displaySpan = sliderElement.nextElementSibling;
            if (displaySpan && displaySpan.classList.contains('value-display')) {
                displaySpan.textContent = `${percentage}%`;
            }
        }
    }
    
    function setBatchLines(lineIds, percentage, batchSliderElement = null) {
        lineIds.forEach(baseId => {
            updateLineLength(baseId, percentage);
            currentLinePercentages[baseId] = percentage;
            const testTabSlider = document.getElementById(`slider-test-${baseId}`);
            updateSliderUI(testTabSlider, percentage);
        });
        if (batchSliderElement) {
            updateSliderUI(batchSliderElement, percentage);
        }
    }

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabPanes.forEach(pane => pane.classList.remove('active'));
            button.classList.add('active');
            currentActiveTabId = button.getAttribute('data-tab'); 
            const activePane = document.getElementById(currentActiveTabId);
            if (activePane) activePane.classList.add('active');

            BASE_LINE_IDS.forEach(baseId => {
                updateLineLength(baseId, 100);
                currentLinePercentages[baseId] = 100;
            });
            document.querySelectorAll('input[type="range"][data-base-lineid], input[type="range"][data-batch-type]').forEach(slider => {
                 updateSliderUI(slider, 100);
            });
            if (presetSelect.value !== "none") {
                presetSelect.value = "none";
                if (presetColorSelect) {
                    presetColorSelect.value = "none";
                    presetColorSelect.disabled = true;
                }
                currentPresetColorOption = "none";
                updatePresetSelectAppearance("none"); // Reset appearance
            }
            saveOmniIndexState(); // Save state on tab change
        });
    });
    
    function getSliderValueFromPercentage(percentage) {
        const index = percentageMap.indexOf(percentage);
        return index !== -1 ? index : 4; 
    }

    function populateLineControlsForTab(tabPaneElement, baseLineIdsArray) {
        if (!tabPaneElement || !baseLineIdsArray || baseLineIdsArray.length === 0) return;
        const h4 = tabPaneElement.querySelector('h4'); 
        tabPaneElement.innerHTML = ''; 
        if (h4) tabPaneElement.appendChild(h4);
        
        const p = document.createElement('p');
        p.className = 'placeholder-text';
        p.textContent = `Controls for ${h4 ? h4.textContent.replace(' Controls', '') : tabPaneElement.id}:`;
        tabPaneElement.appendChild(p);
        
        const createSliderGroup = (labelText, idSuffix, batchTypeOrBaseId, relevantLineIds) => {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'slider-container batch-control-group';
            const label = document.createElement('label');
            const sliderFullId = `slider-${idSuffix}`;
            label.htmlFor = sliderFullId;
            label.textContent = labelText;
            label.style.fontWeight = 'bold';
            label.style.minWidth = '150px';
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.id = sliderFullId;
            slider.min = "0";
            slider.max = "4";
            slider.step = "1";
            const isBatch = Array.isArray(relevantLineIds) && relevantLineIds.length > 1;
            if (isBatch) slider.dataset.batchType = batchTypeOrBaseId;
            else slider.dataset.baseLineid = batchTypeOrBaseId; 
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'value-display';
            valueDisplay.style.minWidth = '40px';
            let initialPercentage = 100;
            if (isBatch) {
                const firstLineId = relevantLineIds[0];
                if (currentLinePercentages.hasOwnProperty(firstLineId)) {
                    const firstLinePercentage = currentLinePercentages[firstLineId];
                    if (relevantLineIds.every(id => currentLinePercentages[id] === firstLinePercentage)) {
                        initialPercentage = firstLinePercentage;
                    }
                }
            } else { 
                 initialPercentage = currentLinePercentages[batchTypeOrBaseId] !== undefined ? currentLinePercentages[batchTypeOrBaseId] : 100;
            }
            slider.value = getSliderValueFromPercentage(initialPercentage);
            valueDisplay.textContent = `${initialPercentage}%`;
            slider.addEventListener('input', function() {
                const currentSliderVal = parseInt(this.value);
                const percentage = percentageMap[currentSliderVal];
                valueDisplay.textContent = `${percentage}%`;
                const linesToUpdate = isBatch ? relevantLineIds : [batchTypeOrBaseId];
                linesToUpdate.forEach(baseId => {
                    updateLineLength(baseId, percentage);
                    currentLinePercentages[baseId] = percentage;
                });
                if (presetSelect.value !== "none") {
                    presetSelect.value = "none";
                    if (presetColorSelect) {
                        presetColorSelect.value = "none";
                        presetColorSelect.disabled = true;
                    }
                    currentPresetColorOption = "none";
                    updatePresetSelectAppearance("none"); // Reset appearance
                }
                saveOmniIndexState(); // Save state when a dynamic slider changes
                if (isBatch) { 
                    linesToUpdate.forEach(baseId => { 
                        document.querySelectorAll(`input[type="range"][data-base-lineid="${baseId}"]`).forEach(indSlider => {
                            if (!indSlider.id.includes('-batch-')) updateSliderUI(indSlider, percentage);
                        });
                    });
                    if (batchTypeOrBaseId === "border") {
                         const otherTabId = tabPaneElement.id === "stars" ? "bars" : "stars";
                         const otherBatchSlider = document.getElementById(`slider-${otherTabId}-batch-border`);
                         updateSliderUI(otherBatchSlider, percentage);
                    }
                } else { 
                    const singleBaseId = batchTypeOrBaseId;
                    document.querySelectorAll(`input[type="range"][data-base-lineid="${singleBaseId}"]`).forEach(otherIndSlider => {
                        if (otherIndSlider !== this && !otherIndSlider.id.includes('-batch-')) updateSliderUI(otherIndSlider, percentage);
                    });
                }
            });
            groupDiv.appendChild(label); groupDiv.appendChild(slider); groupDiv.appendChild(valueDisplay);
            tabPaneElement.appendChild(groupDiv);
        };

        if (tabPaneElement.id === "stars" || tabPaneElement.id === "bars") {
            createSliderGroup("ALL BORDERS:", `${tabPaneElement.id}-batch-border`, "border", BASE_LINE_IDS.filter(id => id.startsWith("border-")));
        }
        if (tabPaneElement.id === "bars") {
            for(const batchKey in batchedInBarsSetup) {
                const label = batchKey.replace(/-/g, ' ').replace('spokes', '').replace('stars', '').trim().split(' ').map(w => w[0].toUpperCase() + w.substring(1)).join(' ') + ":";
                createSliderGroup(label, `bars-batch-${batchKey}`, batchKey, batchedInBarsSetup[batchKey]);
            }
        }
        if (tabPaneElement.id === "stars") {
             for(const batchKey in batchedInStarsSetup) {
                let label = batchKey.replace(/-/g, ' ').replace('spokes', '').replace('stars', '').trim().split(' ').map(w => w[0].toUpperCase() + w.substring(1)).join(' ');
                if (label === "Y Batch" || label === "A Batch" || label === "Horizontal" || label === "Diagonal Edge") {} else { label += ":"; } 
                createSliderGroup(label, `stars-batch-${batchKey}`, batchKey, batchedInStarsSetup[batchKey]);
            }
        }
        baseLineIdsArray.forEach(baseLineId => {
            let skip = false;
            if ((tabPaneElement.id === "stars" || tabPaneElement.id === "bars") && baseLineId.startsWith("border-")) skip = true;
            if (!skip && tabPaneElement.id === "bars") {
                for (const batchKey in batchedInBarsSetup) if (batchedInBarsSetup[batchKey].includes(baseLineId)) {skip = true; break;}
            }
            if (!skip && tabPaneElement.id === "stars") {
                for (const batchKey in batchedInStarsSetup) if (batchedInStarsSetup[batchKey].includes(baseLineId)) {skip = true; break;}
            }
            if (skip) return;
            createSliderGroup(`${baseLineId.replace('hex-', '').replace('border-', 'B:').replace('spoke-c-', 'S:' )}:`, `${tabPaneElement.id}-${baseLineId}`, baseLineId, [baseLineId]);
        });
        
        if (tabPaneElement.id === 'test') {
            const testButton = document.createElement('button');
            testButton.className = 'randomize-button';
            testButton.style.width = '100%';
            testButton.style.marginTop = '15px';
            testButton.textContent = 'Test Action';
            tabPaneElement.appendChild(testButton);
        } else if (tabPaneElement.id === 'stars' || tabPaneElement.id === 'bars') {
            const randomizeButton = document.createElement('button');
            randomizeButton.className = 'randomize-button';
            randomizeButton.id = `randomize-${tabPaneElement.id}`;
            randomizeButton.textContent = 'Randomize Tab Settings';
            randomizeButton.style.width = '100%';
            randomizeButton.style.marginTop = '20px';
            randomizeButton.addEventListener('click', () => randomizeTabSettings(tabPaneElement.id)); 
            tabPaneElement.appendChild(randomizeButton);

            const resetButton = document.createElement('button');
            resetButton.className = 'reset-defaults-button'; 
            // Reset button is now global, so removed from here.
        }
    }

    function resetAllSettingsToDefaults() { // Renamed
        console.log('Resetting ALL settings to defaults...');

        // Reset Zoom
        currentZoom = 1.0;
        if (zoomSlider) zoomSlider.value = currentZoom;
        if (zoomValueDisplay) zoomValueDisplay.textContent = `${currentZoom.toFixed(1)}x`;
        if (svgContainer) svgContainer.setAttribute('viewBox', `${initialViewBox.x} ${initialViewBox.y} ${initialViewBox.width} ${initialViewBox.height}`);
        // No redraw needed for zoom reset, only viewBox change.

        currentGlobalLineColor = '#000000';
        updateGlobalLineColor(currentGlobalLineColor); 
        if (globalLineColorSelect) globalLineColorSelect.value = currentGlobalLineColor;
        
        if (presetSelect) presetSelect.value = "none";
        if (presetColorSelect) {
            presetColorSelect.value = "none";
            presetColorSelect.disabled = true;
        }
        currentPresetColorOption = "none";
        updatePresetSelectAppearance("none"); // Reset appearance

        const barsTabButton = document.querySelector('.tab-button[data-tab="bars"]');
        if (barsTabButton) {
            if (!barsTabButton.classList.contains('active')) {
                barsTabButton.click(); 
            } else {
                BASE_LINE_IDS.forEach(baseId => {
                    updateLineLength(baseId, 100);
                    currentLinePercentages[baseId] = 100;
                });
                document.querySelectorAll('input[type="range"][data-base-lineid], input[type="range"][data-batch-type]').forEach(slider => {
                     updateSliderUI(slider, 100);
                });
                // presetSelect and presetColorSelect already set to none above
                saveOmniIndexState(); 
            }
        }
        currentGlobalLineWeight = allowedLineWeights[0]; // Use the first from allowed list
        isLineWeightLocked = true;
        if (globalLineWeightSlider) globalLineWeightSlider.value = currentGlobalLineWeight;
        if (globalLineWeightValueDisplay) globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1); // Ensure display is for the value, not index
        if (lockLineWeightCheckbox) lockLineWeightCheckbox.checked = isLineWeightLocked;
        updateGlobalLineWeight(currentGlobalLineWeight);
        
        currentBackgroundColor = DEFAULT_BACKGROUND_COLOR;
        isBackgroundColorLocked = DEFAULT_BACKGROUND_LOCK;
        if (backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
        if (lockBackgroundColorCheckbox) lockBackgroundColorCheckbox.checked = isBackgroundColorLocked;
        if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;

    // IMPORTANT for State Management (likely in functions defined after the current visible code):
    // 1. `saveOmniIndexState()`:
    //    - Must be updated to save `currentZoom` (e.g., `state.zoomLevel = currentZoom;`)
    //    - Remove any saving of the old hexagon size.
    // 2. `loadOmniIndexState()`:
    //    - Must be updated to load `currentZoom` (e.g., `state.zoomLevel`).
    //    - Apply the loaded zoom level to `zoomSlider.value`, `zoomValueDisplay.textContent`, and `currentZoom`.
    //    - Critically, it must recalculate and set the SVG `viewBox` based on the loaded `currentZoom` and `initialViewBox`.
    //    - Remove any loading/application of the old hexagon size.
    //    - If no zoom level is in saved state, default to 1.0x and apply the initialViewBox.
    // 3. Initial Drawing:
    //    - The main call to `drawHexagonGrid(...)` should use `FIXED_HEX_RADIUS` (which is 75).
    //      e.g., `drawHexagonGrid(svgContainer, initialViewBox, FIXED_HEX_RADIUS);`
    //      This function is called once to draw the pattern; zoom only changes the view.
        
        // Set slider to correct index for the currentGlobalLineWeight
        const weightIndex = allowedLineWeights.indexOf(currentGlobalLineWeight);
        if (globalLineWeightSlider) globalLineWeightSlider.value = weightIndex !== -1 ? weightIndex : 0;
        if (globalLineWeightValueDisplay) globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1); // Ensure display is for the value

        // Redraw the grid with the fixed size and reset line lengths
        redrawGridAndUpdateControls(FIXED_HEX_RADIUS, false);
        // Note: redrawGridAndUpdateControls will repopulate tab controls, which will set sliders to 100%
        // and currentLinePercentages will be reset if preserveLengths is false.

        // Ensure the active tab's sliders are visually reset if they weren't by redraw
        // This might be redundant if redrawGridAndUpdateControls correctly resets everything.
        document.querySelectorAll(`#${currentActiveTabId} input[type="range"][data-base-lineid], #${currentActiveTabId} input[type="range"][data-batch-type]`).forEach(slider => {
            updateSliderUI(slider, 100);
        });
        
        saveOmniIndexState(); // Save all reset states
    }

    function redrawGridAndUpdateControls(radius, preserveLengths = false) {
        if (svgContainer) {
            if (!preserveLengths) BASE_LINE_IDS.forEach(id => currentLinePercentages[id] = 100);
            // Draw with FIXED_HEX_RADIUS and initialViewBox. Zoom is handled by SVG's viewBox attribute directly.
            drawHexagonGrid(svgContainer, FIXED_HEX_RADIUS, initialViewBox, currentGlobalLineColor, currentGlobalLineWeight);
            BASE_LINE_IDS.forEach(baseId => updateLineLength(baseId, currentLinePercentages[baseId]));
            ['stars', 'bars'].forEach(tabId => { 
                const tabElement = document.getElementById(tabId);
                if (tabElement) populateLineControlsForTab(tabElement, BASE_LINE_IDS);
            });
        } else console.error('SVG container #omniVisualizationSvg not found!');
    }
    
    function getPresetAccentColor(presetName) {
        return PRESET_ACCENT_COLORS[presetName] || PRESET_ACCENT_COLORS.none;
    }

    function updatePresetSelectAppearance(presetName) {
        if (!presetSelect) return;
        const accentColor = getPresetAccentColor(presetName);
        if (presetName === 'none' || accentColor === PRESET_ACCENT_COLORS.none) {
            presetSelect.style.backgroundColor = DEFAULT_SELECT_BG_COLOR;
            presetSelect.style.color = '#000000';
        } else {
            presetSelect.style.backgroundColor = accentColor;
            presetSelect.style.color = '#000000'; // Ensure black text for contrast
        }
    }

    function applyPresetColorOption(optionValue, activePresetName) {
        currentPresetColorOption = optionValue;
        let newLineEditColor = currentGlobalLineColor;
        let newBgColor = currentBackgroundColor;
        const presetAccent = getPresetAccentColor(activePresetName);

        if (activePresetName === 'none' || optionValue === 'none') {
            // When 'none' is selected for preset color, or if the main preset is 'none',
            // colors are determined by manual controls, not by this function.
            // The UI for presetColorSelect should be set to 'none' by the caller.
            return;
        }

        switch (optionValue) {
            case 'color-on-white': newLineEditColor = presetAccent; newBgColor = GREY_COLORS.white; break;
            case 'light-grey-on-white': newLineEditColor = GREY_COLORS.light; newBgColor = GREY_COLORS.white; break;
            case 'medium-grey-on-white': newLineEditColor = GREY_COLORS.medium; newBgColor = GREY_COLORS.white; break;
            case 'black-on-white': newLineEditColor = GREY_COLORS.black; newBgColor = GREY_COLORS.white; break;
            case 'black-on-color': newLineEditColor = GREY_COLORS.black; newBgColor = presetAccent; break;
            case 'color-on-black': newLineEditColor = presetAccent; newBgColor = GREY_COLORS.black; break;
            case 'color-on-light-grey': newLineEditColor = presetAccent; newBgColor = GREY_COLORS.light; break;
            case 'black-on-light-grey': newLineEditColor = GREY_COLORS.black; newBgColor = GREY_COLORS.light; break;
            case 'medium-grey-on-light-grey': newLineEditColor = GREY_COLORS.medium; newBgColor = GREY_COLORS.light; break;
            case 'color-on-medium-grey': newLineEditColor = presetAccent; newBgColor = GREY_COLORS.medium; break;
            case 'black-on-medium-grey': newLineEditColor = GREY_COLORS.black; newBgColor = GREY_COLORS.medium; break;
            case 'light-grey-on-medium-grey': newLineEditColor = GREY_COLORS.light; newBgColor = GREY_COLORS.medium; break;
        }

        if (!isLineColorLocked) {
            currentGlobalLineColor = newLineEditColor;
            if (globalLineColorSelect) globalLineColorSelect.value = currentGlobalLineColor;
            updateGlobalLineColor(currentGlobalLineColor);
        }
        if (!isBackgroundColorLocked) {
            currentBackgroundColor = newBgColor;
            if (backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
            if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
        }
    }

   function applyPreset(presetName) {
        if (presetName === "none") {
            // If preset is set to 'none' (e.g. by manual control change),
            // ensure presetColorSelect also goes to 'none' and is disabled.
            if (presetColorSelect) {
                presetColorSelect.value = "none";
                presetColorSelect.disabled = true;
            }
            currentPresetColorOption = "none";
            updatePresetSelectAppearance("none"); // Update main preset dropdown style
            // Don't apply any further preset logic. Colors/lengths are now manual.
            saveOmniIndexState();
            return;
        }

        // A specific preset is chosen
        if (presetColorSelect) presetColorSelect.disabled = false; // Enable it
        currentGlobalLineWeight = allowedLineWeights[0]; // Default to 1.0 for presets
        updateGlobalLineWeight(currentGlobalLineWeight);
        const weightIndexForPreset = allowedLineWeights.indexOf(currentGlobalLineWeight);
        if (globalLineWeightSlider) globalLineWeightSlider.value = weightIndexForPreset !== -1 ? weightIndexForPreset : 0; 
        if (globalLineWeightValueDisplay) globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
        isLineWeightLocked = false; if (lockLineWeightCheckbox) lockLineWeightCheckbox.checked = false;
        
        // Set default preset color option and apply it
        if (presetColorSelect) presetColorSelect.value = 'color-on-white';
        applyPresetColorOption('color-on-white', presetName); // This handles line and bg color based on locks

        // Applying a preset also unlocks line color and background color by default
        isLineColorLocked = false; if (lockLineColorCheckbox) lockLineColorCheckbox.checked = false;
        isBackgroundColorLocked = false; if (lockBackgroundColorCheckbox) lockBackgroundColorCheckbox.checked = false;


        const barsTabButton = document.querySelector('.tab-button[data-tab="bars"]');
        let isBarsActive = barsTabButton.classList.contains('active');
        if (barsTabButton && !isBarsActive) barsTabButton.click(); 

        setTimeout(() => {
            const borderLines = BASE_LINE_IDS.filter(id => id.startsWith("border-"));
            setBatchLines(borderLines, 75, document.getElementById(`slider-bars-batch-border`));
            const starsBorderBatchSlider = document.getElementById(`slider-stars-batch-border`);
            if (starsBorderBatchSlider) updateSliderUI(starsBorderBatchSlider, 75);
            
            const targetBarsBatchPercentages = {}; 
            // Preset accent color is now handled by applyPresetColorOption, so no need for colorToApply here
            // Update the appearance of the presetSelect dropdown itself
            updatePresetSelectAppearance(presetName);

            switch (presetName) {
                case "egnyte": targetBarsBatchPercentages["vertical-spokes"] = 75; targetBarsBatchPercentages["horizontal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-corner-spokes"] = 75; break;
                case "aec": targetBarsBatchPercentages["vertical-spokes"] = 75; targetBarsBatchPercentages["horizontal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-corner-spokes"] = 75; break;
                case "financial":  targetBarsBatchPercentages["vertical-spokes"] = 75; targetBarsBatchPercentages["horizontal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-corner-spokes"] = 0; break;
                case "lifesciences": targetBarsBatchPercentages["vertical-spokes"] = 0; targetBarsBatchPercentages["horizontal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-corner-spokes"] = 0; break;
                case "channel":  targetBarsBatchPercentages["vertical-spokes"] = 0; targetBarsBatchPercentages["horizontal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-corner-spokes"] = 75; break;
                case "media":  targetBarsBatchPercentages["vertical-spokes"] = 0; targetBarsBatchPercentages["horizontal-edge-spokes"] = 0; targetBarsBatchPercentages["diagonal-edge-spokes"] = 75; targetBarsBatchPercentages["diagonal-corner-spokes"] = 0; break;
            }
            
            for (const batchKey in batchedInBarsSetup) { 
                if (targetBarsBatchPercentages.hasOwnProperty(batchKey)) {
                    const linesInBatch = batchedInBarsSetup[batchKey];
                    const percentage = targetBarsBatchPercentages[batchKey];
                    const batchSliderElement = document.getElementById(`slider-bars-batch-${batchKey}`);
                    setBatchLines(linesInBatch, percentage, batchSliderElement);
                }
            }
            saveOmniIndexState(); // Save after all preset changes are applied
        }, isBarsActive ? 10 : 50); 
    }

    const randomPercentageMap = [0, 25, 50, 75];
    function getRandomPercentage() { return randomPercentageMap[Math.floor(Math.random() * randomPercentageMap.length)]; }

    function randomizeTabSettings(tabId) {
        if (presetSelect) presetSelect.value = "none";
        if (presetColorSelect) {
            presetColorSelect.value = "none";
            presetColorSelect.disabled = true;
        }
        currentPresetColorOption = "none";
        updatePresetSelectAppearance("none"); // Reset appearance

        if (!isBackgroundColorLocked) {
            // Randomize background or set to default? Let's set to default for now.
            currentBackgroundColor = DEFAULT_BACKGROUND_COLOR; 
            if (backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
            if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
        }

        const relevantBatchSetup = (tabId === "stars") ? batchedInStarsSetup : batchedInBarsSetup;
        const borderPercentage = getRandomPercentage();
        const borderLines = BASE_LINE_IDS.filter(id => id.startsWith("border-"));
        const borderBatchSlider = document.getElementById(`slider-${tabId}-batch-border`);
        setBatchLines(borderLines, borderPercentage, borderBatchSlider);
        for (const batchKey in relevantBatchSetup) {
            const batchPercentage = getRandomPercentage();
            const linesInBatch = relevantBatchSetup[batchKey];
            const batchSlider = document.getElementById(`slider-${tabId}-batch-${batchKey}`);
            setBatchLines(linesInBatch, batchPercentage, batchSlider);
        }
        if (tabId === "stars") {
            BASE_LINE_IDS.forEach(baseLineId => {
                let isBatched = baseLineId.startsWith("border-");
                for (const batchKey in batchedInStarsSetup) if (batchedInStarsSetup[batchKey].includes(baseLineId)) { isBatched = true; break; }
                if (!isBatched) {
                    const individualPercentage = getRandomPercentage();
                    updateLineLength(baseLineId, individualPercentage);
                    currentLinePercentages[baseLineId] = individualPercentage;
                    const indSlider = document.getElementById(`slider-stars-${baseLineId}`);
                    updateSliderUI(indSlider, individualPercentage);
                }
            });
        }
        if (!isLineColorLocked) {
            const colorOptions = globalLineColorSelect.options;
            const randomColorIndex = Math.floor(Math.random() * colorOptions.length);
            currentGlobalLineColor = colorOptions[randomColorIndex].value;
            updateGlobalLineColor(currentGlobalLineColor);
            globalLineColorSelect.value = currentGlobalLineColor;
        }
        if (!isLineWeightLocked) {
            const randomIndex = Math.floor(Math.random() * allowedLineWeights.length);
            currentGlobalLineWeight = allowedLineWeights[randomIndex];
            updateGlobalLineWeight(currentGlobalLineWeight);
            globalLineWeightSlider.value = randomIndex;
            globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
        }
        saveOmniIndexState(); // Save state after randomizing
    }

    function saveOmniIndexState() {
        const state = {
            currentGlobalLineColor, currentGlobalLineWeight, isLineColorLocked, isLineWeightLocked,
            currentBackgroundColor, isBackgroundColorLocked,
            currentPresetColorOption, 
            isCustomizerExpanded, // Save customizer state
            currentActiveTabId: document.querySelector('.tab-button.active')?.dataset.tab || 'bars',
            currentLinePercentages: { ...currentLinePercentages },
            zoomLevel: currentZoom, // Changed from hexagonSize
            presetValue: presetSelect.value,
            presetColorValue: presetColorSelect.value
        };
        localStorage.setItem(OMNI_INDEX_STATE_KEY, JSON.stringify(state));
        console.log('Omni Index state saved:', state);
    }

    function loadOmniIndexState() {
        const savedStateString = localStorage.getItem(OMNI_INDEX_STATE_KEY);
        if (savedStateString) {
            try {
                const savedState = JSON.parse(savedStateString);
                console.log('Omni Index state loaded:', savedState);
                currentGlobalLineColor = savedState.currentGlobalLineColor || '#000000';
                let loadedWeight = savedState.hasOwnProperty('currentGlobalLineWeight') ? savedState.currentGlobalLineWeight : allowedLineWeights[0];
                if (!allowedLineWeights.includes(loadedWeight)) {
                    loadedWeight = allowedLineWeights[0]; // Default to 1.0 if saved weight is invalid
                }
                currentGlobalLineWeight = loadedWeight;
                isLineColorLocked = savedState.isLineColorLocked || false;
                isLineWeightLocked = savedState.hasOwnProperty('isLineWeightLocked') ? savedState.isLineWeightLocked : true;
                
                currentBackgroundColor = savedState.currentBackgroundColor || DEFAULT_BACKGROUND_COLOR;
                isBackgroundColorLocked = savedState.hasOwnProperty('isBackgroundColorLocked') ? savedState.isBackgroundColorLocked : DEFAULT_BACKGROUND_LOCK;
                
                currentPresetColorOption = savedState.currentPresetColorOption || DEFAULT_PRESET_COLOR_OPTION;
                isCustomizerExpanded = savedState.hasOwnProperty('isCustomizerExpanded') ? savedState.isCustomizerExpanded : false;
                let loadedPresetValue = savedState.presetValue || 'none';
                let loadedPresetColorValue = savedState.presetColorValue || 'none';

                currentActiveTabId = savedState.currentActiveTabId || 'bars';
                
                // Ensure currentLinePercentages is properly initialized before assigning from savedState
                BASE_LINE_IDS.forEach(id => { 
                    currentLinePercentages[id] = (savedState.currentLinePercentages && typeof savedState.currentLinePercentages === 'object' && savedState.currentLinePercentages.hasOwnProperty(id)) 
                                                ? savedState.currentLinePercentages[id] 
                                                : 100;
                });
                // The Object.assign was removed as the loop above handles it more safely.

                currentZoom = savedState.zoomLevel || 1.0;
                if (zoomSlider) zoomSlider.value = currentZoom;
                if (zoomValueDisplay) zoomValueDisplay.textContent = `${currentZoom.toFixed(1)}x`;

                // Apply loaded zoom to SVG viewBox
                if (svgContainer) {
                    const newViewBoxX = initialViewBox.x / currentZoom;
                    const newViewBoxY = initialViewBox.y / currentZoom;
                    const newViewBoxWidth = initialViewBox.width / currentZoom;
                    const newViewBoxHeight = initialViewBox.height / currentZoom;
                    svgContainer.setAttribute('viewBox', `${newViewBoxX} ${newViewBoxY} ${newViewBoxWidth} ${newViewBoxHeight}`);
                }
                
                globalLineColorSelect.value = currentGlobalLineColor;
                lockLineColorCheckbox.checked = isLineColorLocked;
                
                const loadedWeightIndex = allowedLineWeights.indexOf(currentGlobalLineWeight);
                globalLineWeightSlider.value = loadedWeightIndex !== -1 ? loadedWeightIndex : 0;
                globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
                
                lockLineWeightCheckbox.checked = isLineWeightLocked;
                
                if (backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
                if (lockBackgroundColorCheckbox) lockBackgroundColorCheckbox.checked = isBackgroundColorLocked;
                if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
                
                if (presetSelect) presetSelect.value = loadedPresetValue;
                if (presetColorSelect) {
                    presetColorSelect.value = loadedPresetColorValue;
                    presetColorSelect.disabled = (loadedPresetValue === 'none');
                }
                
                updatePresetSelectAppearance(loadedPresetValue); // Update style of presetSelect

                // If a preset was loaded, re-apply its color option logic
                // This ensures consistency if locks were changed or state was manually edited
                if (loadedPresetValue !== 'none' && loadedPresetColorValue !== 'none') {
                    applyPresetColorOption(loadedPresetColorValue, loadedPresetValue);
                }

                // Apply customizer expanded state
                if (customizerContent && customizerSection) {
                    if (isCustomizerExpanded) {
                        customizerContent.style.display = 'block';
                        customizerSection.classList.add('expanded');
                    } else {
                        customizerContent.style.display = 'none';
                        customizerSection.classList.remove('expanded');
                    }
                }


                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanes.forEach(pane => pane.classList.remove('active'));
                const tabToActivate = document.querySelector(`.tab-button[data-tab="${currentActiveTabId}"]`);
                if (tabToActivate) tabToActivate.classList.add('active');
                const paneToActivate = document.getElementById(currentActiveTabId);
                if (paneToActivate) paneToActivate.classList.add('active');
                
                redrawGridAndUpdateControls(FIXED_HEX_RADIUS, true);
                return true;
            } catch (e) { console.error('Error loading Omni Index state:', e); }
        }
        return false; 
    }

    document.addEventListener('DOMContentLoaded', () => {
        if (!loadOmniIndexState()) { // Apply defaults if no saved state or loading failed
            currentZoom = 1.0;
            if (zoomSlider) zoomSlider.value = currentZoom;
            if (zoomValueDisplay) zoomValueDisplay.textContent = `${currentZoom.toFixed(1)}x`;
            if (svgContainer) svgContainer.setAttribute('viewBox', `${initialViewBox.x} ${initialViewBox.y} ${initialViewBox.width} ${initialViewBox.height}`);
            
            BASE_LINE_IDS.forEach(id => currentLinePercentages[id] = 100);
            currentGlobalLineColor = '#000000'; 
            currentGlobalLineWeight = allowedLineWeights[0]; // Default to 1.0
            currentBackgroundColor = DEFAULT_BACKGROUND_COLOR;
            currentPresetColorOption = DEFAULT_PRESET_COLOR_OPTION;
            isCustomizerExpanded = false; // Default to collapsed
            isLineColorLocked = false; 
            isLineWeightLocked = true; 
            isBackgroundColorLocked = DEFAULT_BACKGROUND_LOCK;
            currentActiveTabId = 'bars';

            if(globalLineColorSelect) globalLineColorSelect.value = currentGlobalLineColor;
            if(lockLineColorCheckbox) lockLineColorCheckbox.checked = isLineColorLocked;
            
            const defaultWeightIndex = allowedLineWeights.indexOf(currentGlobalLineWeight);
            if(globalLineWeightSlider) globalLineWeightSlider.value = defaultWeightIndex !== -1 ? defaultWeightIndex : 0;
            if(globalLineWeightValueDisplay) globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
            if(lockLineWeightCheckbox) lockLineWeightCheckbox.checked = isLineWeightLocked;

            if(backgroundColorSelect) backgroundColorSelect.value = currentBackgroundColor;
            if(lockBackgroundColorCheckbox) lockBackgroundColorCheckbox.checked = isBackgroundColorLocked;
            if(svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
            
            if(presetSelect) presetSelect.value = 'none';
            if(presetColorSelect) {
                presetColorSelect.value = 'none';
                presetColorSelect.disabled = true;
            }
            updatePresetSelectAppearance('none'); // Set initial style for presetSelect
            
            // Set initial customizer state (collapsed)
            if (customizerContent && customizerSection) {
                customizerContent.style.display = 'none';
                customizerSection.classList.remove('expanded');
            }


            document.querySelector('.tab-button[data-tab="bars"]')?.classList.add('active');
            const barsPane = document.getElementById('bars'); if (barsPane) barsPane.classList.add('active');
            document.querySelector('.tab-button[data-tab="stars"]')?.classList.remove('active');
            const starsPane = document.getElementById('stars'); if (starsPane) starsPane.classList.remove('active');
            redrawGridAndUpdateControls(FIXED_HEX_RADIUS, false);
        }

        // Event listener for the new zoomSlider
        if (zoomSlider) {
            zoomSlider.addEventListener('input', function() {
                currentZoom = parseFloat(this.value);
                if (zoomValueDisplay) {
                    zoomValueDisplay.textContent = `${currentZoom.toFixed(1)}x`;
                }

                const newViewBoxX = initialViewBox.x / currentZoom;
                const newViewBoxY = initialViewBox.y / currentZoom;
                const newViewBoxWidth = initialViewBox.width / currentZoom;
                const newViewBoxHeight = initialViewBox.height / currentZoom;
                
                const newViewBoxString = `${newViewBoxX} ${newViewBoxY} ${newViewBoxWidth} ${newViewBoxHeight}`;

                if (svgContainer) {
                    svgContainer.setAttribute('viewBox', newViewBoxString);
                }
                saveOmniIndexState();
            });
        }
        // Old hexagonSizeSlider event listener REMOVED.

        globalLineColorSelect.addEventListener('change', function() {
            currentGlobalLineColor = this.value;
            updateGlobalLineColor(currentGlobalLineColor);
            if (presetSelect.value !== "none") {
                presetSelect.value = "none";
                if (presetColorSelect) {
                    presetColorSelect.value = "none";
                    presetColorSelect.disabled = true;
                }
                currentPresetColorOption = "none";
                updatePresetSelectAppearance("none");
            }
            saveOmniIndexState();
        });
        lockLineColorCheckbox.addEventListener('change', function() { 
            isLineColorLocked = this.checked; 
            // If unchecking while a preset color option is active, the color might change
            if (!isLineColorLocked && presetSelect.value !== 'none' && presetColorSelect.value !== 'none') {
                 applyPresetColorOption(presetColorSelect.value, presetSelect.value);
            }
            saveOmniIndexState();
        });
        globalLineWeightSlider.addEventListener('input', function() {
            const selectedIndex = parseInt(this.value);
            currentGlobalLineWeight = allowedLineWeights[selectedIndex];
            globalLineWeightValueDisplay.textContent = currentGlobalLineWeight.toFixed(1);
            updateGlobalLineWeight(currentGlobalLineWeight);
            // Presets are NOT reset when only line weight changes.
            saveOmniIndexState();
        });
        lockLineWeightCheckbox.addEventListener('change', function() { 
            isLineWeightLocked = this.checked; 
            saveOmniIndexState();
        });
        backgroundColorSelect.addEventListener('change', function() {
            currentBackgroundColor = this.value;
            if (svgContainer) svgContainer.style.backgroundColor = currentBackgroundColor;
            if (presetSelect.value !== "none") {
                presetSelect.value = "none";
                if (presetColorSelect) {
                    presetColorSelect.value = "none";
                    presetColorSelect.disabled = true;
                }
                currentPresetColorOption = "none";
                updatePresetSelectAppearance("none");
            }
            saveOmniIndexState();
        });
        lockBackgroundColorCheckbox.addEventListener('change', function() {
            isBackgroundColorLocked = this.checked;
            if (!isBackgroundColorLocked && presetSelect.value !== 'none' && presetColorSelect.value !== 'none') {
                 applyPresetColorOption(presetColorSelect.value, presetSelect.value);
            }
            saveOmniIndexState();
        });
        presetSelect.addEventListener('change', function() {
            const selectedPresetValue = this.value;
            applyPreset(selectedPresetValue); // applyPreset handles enabling/disabling presetColorSelect internally
                                              // and also sets its default value if a preset is chosen.
            // Explicitly ensure disabled state if "none" is chosen for presetSelect
            if (selectedPresetValue === 'none' && presetColorSelect) {
                 presetColorSelect.disabled = true;
                 presetColorSelect.value = 'none'; // Also reset its value
                 currentPresetColorOption = 'none';
            }
            saveOmniIndexState(); 
        });
        presetColorSelect.addEventListener('change', function() {
            const selectedPreset = presetSelect.value;
            if (selectedPreset !== 'none') {
                applyPresetColorOption(this.value, selectedPreset);
            } else {
                // This case should ideally not be reachable if presetColorSelect is disabled
                // when presetSelect is 'none'. But as a safeguard:
                this.value = 'none'; 
                currentPresetColorOption = 'none';
            }
            saveOmniIndexState();
        });

        const manipulatorLink = document.getElementById('manipulatorLink');
        if (manipulatorLink) manipulatorLink.addEventListener('click', () => saveOmniIndexState());
        const animatorLink = document.getElementById('animatorLink');
        // if (animatorLink) animatorLink.addEventListener('click', () => saveOmniIndexState()); // Animator link removed
        
        const resetAllButton = document.getElementById('resetAllSettingsButton');
        if (resetAllButton) resetAllButton.addEventListener('click', resetAllSettingsToDefaults);

        if (customizerHeader && customizerContent && customizerSection) {
            customizerHeader.addEventListener('click', () => {
                isCustomizerExpanded = !isCustomizerExpanded;
                if (isCustomizerExpanded) {
                    customizerContent.style.display = 'block';
                    customizerSection.classList.add('expanded');
                } else {
                    customizerContent.style.display = 'none';
                    customizerSection.classList.remove('expanded');
                }
                saveOmniIndexState(); // Save the new expanded/collapsed state
            });
        }

        const downloadButton = document.getElementById('downloadSvgButton');
        if (downloadButton) downloadButton.addEventListener('click', handleSvgDownload);
    });

    function handleSvgDownload() {
        const numHexagonsWideUser = parseInt(document.getElementById('hexagonsWideInput').value) || 1;
        const numHexagonsTallUser = parseInt(document.getElementById('hexagonsTallInput').value) || 1;

        const R = FIXED_HEX_RADIUS;
        const finalGlobalStrokeColor = currentGlobalLineColor;
        const finalBackgroundColor = currentBackgroundColor;
        const finalGlobalStrokeWeight = currentGlobalLineWeight;

        const BUFFER_HEX_COUNT = 2; // Number of buffer hexagons on each side
        const numHexagonsWideTotal = numHexagonsWideUser + (BUFFER_HEX_COUNT * 2);
        const numHexagonsTallTotal = numHexagonsTallUser + (BUFFER_HEX_COUNT * 2);

        const hexGridItemWidth = R * Math.sqrt(3);
        const hexGridItemHeight = R * 2;
        const horizSpacing = hexGridItemWidth;
        const vertSpacing = hexGridItemHeight * 0.75;

        console.log(`Downloading SVG: User specified ${numHexagonsWideUser}x${numHexagonsTallUser}, viewBox focuses on user grid, total content ${numHexagonsWideTotal}x${numHexagonsTallTotal}.`);

        // Calculate dimensions for the user-defined artboard / viewBox
        const artboardVisualPadding = R * 0.1; // Small visual padding INSIDE the artboard

        let viewBoxWidth = artboardVisualPadding * 2;
        if (numHexagonsWideUser > 0) {
            const baseUserWidth = (numHexagonsWideUser - 1) * horizSpacing + hexGridItemWidth;
            viewBoxWidth += baseUserWidth;
            if (numHexagonsTallUser > 1) { // If multiple user rows, a staggered row can increase total span
                const staggeredUserWidth = ((numHexagonsWideUser - 0.5) * horizSpacing) + hexGridItemWidth;
                // Ensure the artboardVisualPadding is outside the max of these two calculations
                viewBoxWidth = Math.max(baseUserWidth, staggeredUserWidth) + artboardVisualPadding * 2;
            }
        } else { // No user hexagons wide
            viewBoxWidth = artboardVisualPadding * 2;
        }
        if (numHexagonsWideUser === 1 && numHexagonsTallUser > 1) { // Special case for single column, multiple rows
             viewBoxWidth = hexGridItemWidth + artboardVisualPadding * 2;
        }


        let viewBoxHeight = artboardVisualPadding * 2;
        if (numHexagonsTallUser > 0) {
            viewBoxHeight += (numHexagonsTallUser - 1) * vertSpacing + hexGridItemHeight;
        } else { // No user hexagons tall
            viewBoxHeight = artboardVisualPadding * 2;
        }

        // Determine the minX, minY for the viewBox to center the user-defined grid
        // The user-defined grid starts at (BUFFER_HEX_COUNT, BUFFER_HEX_COUNT) in the total grid
        const firstUserHexGridCol = BUFFER_HEX_COUNT;
        const firstUserHexGridRow = BUFFER_HEX_COUNT;

        // Calculate center of the first hexagon in the USER-DEFINED grid portion
        // (relative to the (0,0) origin of the total buffered content)
        const centerX_of_first_user_hex = (firstUserHexGridCol * horizSpacing) + (firstUserHexGridRow % 2 !== 0 ? horizSpacing / 2 : 0) + (hexGridItemWidth / 2);
        const centerY_of_first_user_hex = (firstUserHexGridRow * vertSpacing) + (hexGridItemHeight / 2); // which is R

        // The viewBox should start at the top-left extent of this first user hexagon, adjusted by artboardVisualPadding
        const viewBoxMinX = centerX_of_first_user_hex - (hexGridItemWidth / 2) - artboardVisualPadding;
        const viewBoxMinY = centerY_of_first_user_hex - (hexGridItemHeight / 2) - artboardVisualPadding;

        // --- Canonical Hexagon Geometry (centered at 0,0) ---
        const BASE_HEX_GEOMETRY = {};
        const getPoint = (radius, angleDegrees) => {
            const angleRadians = (angleDegrees - 90) * Math.PI / 180;
            return { x: radius * Math.cos(angleRadians), y: radius * Math.sin(angleRadians) };
        };

        const corners = {
            p12: getPoint(R, 0), p2: getPoint(R, 60), p4: getPoint(R, 120),
            p6: getPoint(R, 180), p8: getPoint(R, 240), p10: getPoint(R, 300)
        };
        const edgeMidpoints = {
            p1: getPoint(R * Math.sqrt(3) / 2, 30), p3: getPoint(R * Math.sqrt(3) / 2, 90),
            p5: getPoint(R * Math.sqrt(3) / 2, 150), p7: getPoint(R * Math.sqrt(3) / 2, 210),
            p9: getPoint(R * Math.sqrt(3) / 2, 270), p11: getPoint(R * Math.sqrt(3) / 2, 330)
        };
        const center = { x: 0, y: 0 };

        BASE_LINE_IDS.forEach(id => {
            const parts = id.split('-'); // e.g., "border", "p12", "p2" OR "spoke", "c", "p1"
            if (parts[0] === "border") {
                BASE_HEX_GEOMETRY[id] = { p1: corners[parts[1]], p2: corners[parts[2]] };
            } else if (parts[0] === "spoke" && parts[1] === "c") {
                const endPointKey = parts[2];
                BASE_HEX_GEOMETRY[id] = { p1: center, p2: corners[endPointKey] || edgeMidpoints[endPointKey] };
            }
        });
        // --- End Canonical Hexagon Geometry ---

        // --- Helper to get scaled lines for a canonical hexagon ---
        const getScaledLinesForHexagon = (baseGeom, linePercentages) => {
            const scaledLines = [];
            for (const baseId in baseGeom) {
                if (linePercentages.hasOwnProperty(baseId)) {
                    const { p1: originalP1, p2: originalP2 } = baseGeom[baseId];
                    const percentage = linePercentages[baseId];
                    const scale = percentage / 100;

                    let p1Scaled, p2Scaled;
                    if (scale === 0) {
                        const midX = (originalP1.x + originalP2.x) / 2;
                        const midY = (originalP1.y + originalP2.y) / 2;
                        p1Scaled = { x: midX, y: midY };
                        p2Scaled = { x: midX, y: midY };
                    } else {
                        const gapRatio = (1 - scale) / 2;
                        const getPtAlong = (ptA, ptB, ratio) => ({
                            x: ptA.x + (ptB.x - ptA.x) * ratio,
                            y: ptA.y + (ptB.y - ptA.y) * ratio
                        });
                        p1Scaled = getPtAlong(originalP1, originalP2, gapRatio);
                        p2Scaled = getPtAlong(originalP2, originalP1, gapRatio);
                    }
                     // Only add if it's a visible line
                    if (Math.abs(p1Scaled.x - p2Scaled.x) > 0.001 || Math.abs(p1Scaled.y - p2Scaled.y) > 0.001) {
                        scaledLines.push({ x1: p1Scaled.x, y1: p1Scaled.y, x2: p2Scaled.x, y2: p2Scaled.y });
                    }
                }
            }
            return scaledLines;
        };
        // --- End Helper ---

        let svgElements = '';
        const uniqueLines = new Set();
        const getLineKey = (x1, y1, x2, y2, precision = 3) => {
            const p = Math.pow(10, precision);
            const round = val => Math.round(val * p) / p;
            const rX1 = round(x1); const rY1 = round(y1);
            const rX2 = round(x2); const rY2 = round(y2);
            return (rX1 < rX2 || (rX1 === rX2 && rY1 < rY2)) ? `${rX1},${rY1},${rX2},${rY2}` : `${rX2},${rY2},${rX1},${rY1}`;
        };

        const canonicalScaledLines = getScaledLinesForHexagon(BASE_HEX_GEOMETRY, currentLinePercentages);

        if (canonicalScaledLines.length === 0) {
            console.warn("No lines generated from canonical hexagon with current percentages.");
        }

        // Iterate over the total grid size (user + buffer)
        for (let row = 0; row < numHexagonsTallTotal; row++) {
            for (let col = 0; col < numHexagonsWideTotal; col++) {
                // Calculate center of this hexagon in the grid
                // Calculate center of this hexagon in the grid (absolute coordinates from (0,0) of total content)
                const hexCenterX = (col * horizSpacing) + (row % 2 !== 0 ? horizSpacing / 2 : 0) + (hexGridItemWidth / 2);
                const hexCenterY = (row * vertSpacing) + (hexGridItemHeight / 2); // which is R

                canonicalScaledLines.forEach(lineDef => {
                    const absX1 = hexCenterX + lineDef.x1;
                    const absY1 = hexCenterY + lineDef.y1;
                    const absX2 = hexCenterX + lineDef.x2;
                    const absY2 = hexCenterY + lineDef.y2;

                    const lineKey = getLineKey(absX1, absY1, absX2, absY2);
                    if (!uniqueLines.has(lineKey)) {
                        uniqueLines.add(lineKey);
                        svgElements += `  <line x1="${absX1.toFixed(3)}" y1="${absY1.toFixed(3)}" x2="${absX2.toFixed(3)}" y2="${absY2.toFixed(3)}" stroke="${finalGlobalStrokeColor}" stroke-width="${finalGlobalStrokeWeight}" stroke-linecap="round" />\n`;
                    }
                });
            }
        }

        // Background rectangle covers only the viewBox area (artboard)
        const backgroundRect = `<rect x="${viewBoxMinX.toFixed(3)}" y="${viewBoxMinY.toFixed(3)}" width="${viewBoxWidth.toFixed(3)}" height="${viewBoxHeight.toFixed(3)}" fill="${finalBackgroundColor}" />\n`;
        
        // SVG dimensions are based on the viewBox (artboard), viewBox defines the window into the larger content
        const finalSvgString = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg width="${viewBoxWidth.toFixed(3)}" height="${viewBoxHeight.toFixed(3)}" viewBox="${viewBoxMinX.toFixed(3)} ${viewBoxMinY.toFixed(3)} ${viewBoxWidth.toFixed(3)} ${viewBoxHeight.toFixed(3)}" xmlns="http://www.w3.org/2000/svg">\n${backgroundRect}${svgElements}</svg>`;

        const blob = new Blob([finalSvgString], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `hexagon_pattern_grid_${numHexagonsWideUser}x${numHexagonsTallUser}_buffered.svg`; // Added _buffered to filename
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    </script>
</body>
</html>
